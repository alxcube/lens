<script src="lens.min.js"></script>
<script src="js/common.js"></script>
<script>
    // Preload image
    var testTablePromise    = preloadImage('img/affine/test-table.jpg');
</script>

<p><em>See page source for examples code</em></p>

<p>This is the source image we will distort:</p>

<div id="source"></div>

<script>
    testTablePromise.then(function (img) {
      document.querySelector('#source').appendChild(img);
    });
</script>

<p>Apply single control point affine distortion: move origin from (0, 0) to (100, 100):</p>

<div id="translate"></div>

<script>
    testTablePromise.then(function (img) {
      var image = new lens.image.DomImage(img);

      return lens.distort(
        image,
        lens.distorts.AFFINE,
        [0, 0, 100, 100] // Move image origin to (100, 100)
      );
    }).then(function (distorted) {
      document.querySelector('#translate').appendChild(distorted.image);
    });
</script>

<p>
    You can see that image 'moved', but part of it disappeared. That's because distorted image viewport is the same
    as in source image. Let's do the same operation, but with bestFit option:
</p>

<div id="translate_bestFit"></div>

<script>
  testTablePromise.then(function (img) {
    var image = new lens.image.DomImage(img);

    return lens.distort(
      image,
      lens.distorts.AFFINE,
      [0, 0, 100, 100], // Move image origin to (100, 100)
      {bestFit: true}
    );
  }).then(function (distorted) {
    document.querySelector('#translate_bestFit').appendChild(distorted.image);
    console.log(distorted.viewport);
  });
</script>

<p>
    Looks like nothing changed in source image. But that's wrong. First, image bacame smoother bacause of resampling.
    And second, what is more important: it's virtual viewport changed, so you can compose it with other image using
    virtual viewport data to put it in correct position. See browser console to inspect distorted image viewport.
</p>

^ {@tutorial 03.01.affine}