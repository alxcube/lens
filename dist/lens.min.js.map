{"version":3,"sources":["webpack://lens/webpack/universalModuleDefinition","webpack://lens/webpack/bootstrap","webpack://lens/./lib/distorter/reverse-pixel-mapping.js","webpack://lens/./lib/constants.js","webpack://lens/./lib/util/util.js","webpack://lens/./lib/resampler/point.js","webpack://lens/./lib/vpx.js","webpack://lens/./lib/interpolation.js","webpack://lens/./lib/resampler/e-w-a.js","webpack://lens/./lib/filter/filter.js","webpack://lens/./lib/filter/filter-functions.js","webpack://lens/./lib/filter-presets.js","webpack://lens/./lib/distort.js","webpack://lens/./lib/exception/lens-exception.js","webpack://lens/./lib/exception/unsolvable-matrix.js","webpack://lens/./lib/util/gauss-jordan-elimination/solver.js","webpack://lens/./lib/util/gauss-jordan-elimination/least-squares.js","webpack://lens/./lib/viewport.js","webpack://lens/./lib/mixins/creates-bestFit-viewport-from-apexes.js","webpack://lens/./lib/exception/invalid-arguments-length.js","webpack://lens/./lib/distortion/affine.js","webpack://lens/./lib/distortion/perspective.js","webpack://lens/./lib/exception/invalid-argument.js","webpack://lens/./lib/distortion/arc.js","webpack://lens/./lib/mixins/virtual-pixel-trait.js","webpack://lens/./lib/mixins/interpolation-trait.js","webpack://lens/./lib/image/abstract-image.js","webpack://lens/./lib/image/canvas.js","webpack://lens/./lib/image/dom-image.js","webpack://lens/./lib/distorts.js","webpack://lens/./lib/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ReversePixelMapping","image","distortion","resampler","mapper","bestFit","viewport","async","outputScaling","setImage","setMapper","prepareViewport","x1","Math","floor","y1","x2","y2","canvas","getBlank","scaling","Promise","then","performDistortionAsync","performDistortion","y","x","setPixelColor","getResampledColor","args","resolve","setTimeout","clone","hasBestFitViewport","getBestFitViewport","scale","EPSILON","M_PI2","PI","M_2PI","perceptibleReciprocal","sign","blendColors","color1","weight1","color2","weight2","map","channel","round","rad2deg","radians","deg2rad","degrees","Point","matteColor","validity","getValidity","reverseMap","u","v","color","getInterpolatedPixelColor","slice","vpx","BACKGROUND","EDGE","MIRROR","RANDOM","TILE","TRANSPARENT","BLACK","GRAY","WHITE","HORIZONTAL_TILE","VERTICAL_TILE","HORIZONTAL_TILE_EDGE","VERTICAL_TILE_EDGE","interpolation","AVERAGE","AVERAGE_9","AVERAGE_16","INTEGER","WEIGHT_LOOKUP_TABLE_WIDTH","clampToQuantum","quantumRange","max","min","clampEllipseAxes","dux","duy","dvx","dvy","n11","n12","n21","n22","det","twice_det","frobenius_squared","discriminant","sqrt_discriminant","sqrt","s1s1","s2s2","s1s1minusn11","s1s1minusn22","s1s1minusn11_squared","s1s1minusn22_squared","temp_u11","temp_u21","norm","u11","u21","major_mag","minor_mag","EWA","filter","resizeFilter","support","blur","weightLookupTable","table","rScale","Q","getWeight","buildWeightLookupTable","imageViewport","imageArea","imageVirtualPixelMethod","imageAverageColor","A","B","C","F","uLimit","vLimit","uWidth","slope","ellipseIsSetUp","limitReached","hasConstantPartialDerivatives","setupEllipseOnce","getPartialDerivatives","setupEllipse","getWeightedAverage","area","virtualPixelMethod","hasPartialDerivatives","Error","derivatives","derivative","initEllipse","scaleEllipse","major_x","major_y","minor_x","minor_y","u0","v0","doesntNeedResampling","getPixelColor","getImageAverageColor","divisorM","divisorC","red","green","blue","alpha","v1","ceil","v2","u1","uw","DDQ","ustart","uend","U","V","DQ","weight","g","b","a","outOfImageBounds","getAverageColor","Filter","filterFunction","windowingFunction","windowSupport","xBlur","window","box","func","filterFunctionName","cubicBC","p0","p2","p3","q0","q1","q2","q3","filterPresets","ROBIDOUX","ROBIDOUX_SHARP","defaultOptions","resample","distort","options","assign","supersample","makeOptions","forceBestFit","distorted","sync","dist","distorter","makeDistorter","rsm","makeFilter","makeResampler","scaleSupersampled","supersampled","console","warn","e","reject","LensException","message","captureStackTrace","constructor","stack","UnsolvableMatrix","swap","array","row1","col1","row2","col2","unsolvable","Solver","matrix","vectors","solved","row","vector","validate","rank","length","numVectors","cols","Array","fill","rows","pivots","col","j","k","abs","forEach","LeastSquares","push","terms","results","Viewport","width","height","createsBestFitViewportFromApexes","u2","forwardMap","apex","expand","fixBounds","InvalidArgumentsLength","Affine","forwardMatrix","invertAffineMatrix","controlPoints","leastSquares","addTerms","solve","getVectors","concat","determinant","q","Perspective","reverseMatrix","denominator","invertPerspectiveMatrix","inverse","absR","absC6","absC7","pow","InvalidArgument","Arc","c0","c1","c2","c3","c4","angleToWidth","radiusToHeight","getUV","ca","cos","sa","sin","vp","atan2","hypot","getEdgeCoords","getTileCoords","rx","ry","virtualPixelTrait","getVirtualPixelColor","method","vpxMethods","backgroundColor","getImagePixelColor","tx","ty","random","interpolationTrait","interpolationMethod","methods","interpolateAverage","startX","startY","count","endX","endY","Y","X","gamma","notImplemented","AbstractImage","setImagePixelColor","blank","prepareBlank","resized","resize","Canvas","imageData","getContext","getImageData","data","offset","document","createElement","putImageData","drawImage","dst","DomImage","Image","onload","src","toDataURL","distorts","AFFINE","fromControlPoints","AFFINE_PROJECTION","sx","sy","fromForwardMatrix","PERSPECTIVE","PERSPECTIVE_PROJECTION","ARC","fromArguments","registerDistortionResolver","resolver","unregisterDistortionResolver","VERSION"],"mappings":"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","file":"lens.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lens\"] = factory();\n\telse\n\t\troot[\"lens\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * Reverse pixel mapping.\r\n *\r\n * @memberOf lens.distorter\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#mapping Reverse pixel mapping details at ImageMagick docs}\r\n * @tutorial 02.02.reverse-pixel-mapping\r\n */\r\nclass ReversePixelMapping {\r\n\r\n  /**\r\n   *\r\n   * @param {ImageInterface} image Image to be distorted.\r\n   * @param {DistortionInterface} distortion Distortion to be performed.\r\n   * @param {ResamplerInterface} resampler Color resampler.\r\n   */\r\n  constructor(image, distortion, resampler) {\r\n    /**\r\n     * Image being distorted.\r\n     * @type {ImageInterface}\r\n     */\r\n    this.image = image;\r\n\r\n    /**\r\n     * Distortion.\r\n     * @type {DistortionInterface}\r\n     */\r\n    this.mapper = distortion;\r\n\r\n    /**\r\n     * Resampler.\r\n     * @type {ResamplerInterface}\r\n     */\r\n    this.resampler = resampler;\r\n\r\n    /**\r\n     * If set to true, try to calculate best fit viewport.\r\n     * @type {boolean}\r\n     */\r\n    this.bestFit = false;\r\n\r\n    /**\r\n     * Override output viewport.\r\n     * @type {lens.Viewport|null}\r\n     */\r\n    this.viewport = null;\r\n\r\n    /**\r\n     * Run distortion async.\r\n     * @type {boolean}\r\n     */\r\n    this.async = true;\r\n\r\n    /**\r\n     * Output image scaling.\r\n     * @type {number}\r\n     */\r\n    this.outputScaling = 1;\r\n  }\r\n\r\n  /**\r\n   * Distorts image.\r\n   *\r\n   * @returns {Promise<ImageInterface>|ImageInterface} New instance of ImageInterface with distorted image or Promise\r\n   * that resolves distorted ImageInterface instance.\r\n   */\r\n  distort() {\r\n    this.resampler.setImage(this.image);\r\n    this.resampler.setMapper(this.mapper);\r\n\r\n    const viewport = this.prepareViewport();\r\n    const x1 = Math.floor(viewport.x1);\r\n    const y1 = Math.floor(viewport.y1);\r\n    const x2 = Math.floor(viewport.x2);\r\n    const y2 = Math.floor(viewport.y2);\r\n\r\n    const canvas = this.image.getBlank(viewport);\r\n\r\n    this.resampler.scaling = 1 / this.outputScaling;\r\n\r\n    if (canvas instanceof Promise) {\r\n      return canvas.then(canvas => this.performDistortionAsync(canvas, x1, y1, x2, y2));\r\n    } else if (this.async) {\r\n      return this.performDistortionAsync(canvas, x1, y1, x2, y2);\r\n    }\r\n\r\n    return this.performDistortion(canvas, x1, y1, x2, y2);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {ImageInterface} canvas\r\n   * @param {number} x1\r\n   * @param {number} y1\r\n   * @param {number} x2\r\n   * @param {number} y2\r\n   * @returns {ImageInterface}\r\n   */\r\n  performDistortion(canvas, x1, y1, x2, y2) {\r\n    for (let y = y1; y <= y2; y++) {\r\n      for (let x = x1; x <= x2; x++) {\r\n        canvas.setPixelColor(x, y, this.resampler.getResampledColor(x + 0.5, y + 0.5));\r\n      }\r\n    }\r\n\r\n    return canvas;\r\n  }\r\n\r\n  performDistortionAsync(...args) {\r\n    return new Promise(resolve => setTimeout(() => resolve(this.performDistortion(...args), 0)));\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @returns {lens.Viewport}\r\n   */\r\n  prepareViewport() {\r\n    let viewport;\r\n\r\n    if (this.viewport) {\r\n      viewport = this.viewport.clone();\r\n    } else if (this.bestFit && this.mapper.hasBestFitViewport) {\r\n      viewport = this.mapper.getBestFitViewport(this.image.viewport);\r\n    } else {\r\n      viewport = this.image.viewport.clone();\r\n    }\r\n\r\n    viewport.scale(this.outputScaling);\r\n\r\n    return viewport;\r\n  }\r\n}\r\n\r\nexport default ReversePixelMapping;","/**\r\n * @type {number}\r\n * @memberOf lens\r\n */\r\nconst EPSILON = 1.0e-12;\r\n/**\r\n * @type {number}\r\n * @memberOf lens\r\n */\r\nconst MAXIMUM_VALUE = 1.79769313486231570E+308;\r\n\r\n/**\r\n * Pi/2\r\n *\r\n * @type {number}\r\n * @memberOf lens\r\n */\r\nconst M_PI2 = Math.PI / 2;\r\n\r\n/**\r\n * Pi * 2\r\n *\r\n * @memberOf lens\r\n * @type {number}\r\n */\r\nconst M_2PI = Math.PI * 2;\r\n\r\nexport {\r\n  EPSILON,\r\n  MAXIMUM_VALUE,\r\n  M_PI2,\r\n  M_2PI\r\n};","import {EPSILON} from \"../constants\";\r\n\r\n/**\r\n * Return 1/x where x is perceptible (not unlimited or infinitesimal).\r\n *\r\n * @memberOf lens.util\r\n * @param {number} x\r\n * @returns {number}\r\n * @see {@link https://imagemagick.org/api/MagickCore/pixel-accessor_8h_source.html#l00234 PerceptibleReciprocal()}\r\n * at ImageMagick source.\r\n */\r\nfunction perceptibleReciprocal(x) {\r\n  const sign = x < 0 ? -1 : 1;\r\n\r\n  if (sign * x >= EPSILON) {\r\n    return 1 / x;\r\n  }\r\n\r\n  return sign / EPSILON;\r\n}\r\n\r\n/**\r\n * Blends two colors by given weights.\r\n *\r\n * @memberOf lens.util\r\n * @param {Color} color1 First color to blend.\r\n * @param {number} weight1 First color's weight.\r\n * @param {Color} color2 Second color to blend.\r\n * @param {number|null} [weight2] Second color's weight. If not passed -- will be calculated as 1 - weight1.\r\n * @returns {Color} Color blending result.\r\n */\r\nfunction blendColors(color1, weight1, color2, weight2 = null) {\r\n  if (weight2 === null) {\r\n    weight2 = 1 - weight1;\r\n  }\r\n\r\n  return color1.map((channel, i) => Math.round(channel * weight1 + color2[i] * weight2));\r\n}\r\n\r\n/**\r\n * Converts radians to degrees\r\n *\r\n * @memberOf lens.util\r\n * @param {number} radians\r\n * @returns {number}\r\n */\r\nfunction rad2deg(radians) {\r\n  return 180 * radians / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts degrees to radians\r\n *\r\n * @memberOf lens.util\r\n * @param {number} degrees\r\n * @returns {number}\r\n */\r\nfunction deg2rad(degrees) {\r\n  return Math.PI * degrees / 180;\r\n}\r\n\r\nexport {\r\n  blendColors,\r\n  perceptibleReciprocal,\r\n  rad2deg,\r\n  deg2rad\r\n};","import {blendColors} from \"../util/util\";\r\n\r\n/**\r\n * <p>{@link ResamplerInterface} implementaion without resampling itself.</p>\r\n * <p>It uses pixel color interpolation and works much faster than {@link lens.resampler.EWA} but produces aliasing\r\n * effects.</p>\r\n * <p>It is good for quick creation of distortion previews and also used for {@link DistortionInterface} implementations\r\n * that doesn't have partial derivatives.</p>\r\n * <p>It works most quickly when {@link ImageInterface}#interpolationMethod property is set to\r\n * {@link lens.interpolation.INTEGER}</p>\r\n *\r\n * @implements {ResamplerInterface}\r\n * @memberOf lens.resampler\r\n * @tutorial 02.03.pixel-color-lookup\r\n */\r\nclass Point {\r\n\r\n  constructor() {\r\n    this.matteColor = [0, 0, 0, 0];\r\n    this.scaling = 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setImage(image) {\r\n    this.image = image;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setMapper(mapper) {\r\n    this.mapper = mapper;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getResampledColor(x, y) {\r\n    x = x * this.scaling;\r\n    y = y * this.scaling;\r\n\r\n    const validity = this.mapper.getValidity(x, y, this.scaling);\r\n\r\n    if (validity > 0) {\r\n      let [u, v] = this.mapper.reverseMap(x, y);\r\n      let color = this.image.getInterpolatedPixelColor(u, v);\r\n\r\n      if (validity < 1) {\r\n        return blendColors(color, this.matteColor, validity);\r\n      }\r\n\r\n      return color;\r\n    }\r\n\r\n    return this.matteColor.slice();\r\n  }\r\n}\r\n\r\nexport default Point;","/**\r\n * Virtual pixel methods.\r\n *\r\n * @readonly\r\n * @enum {number}\r\n * @memberOf lens\r\n * @see {@link https://www.imagemagick.org/Usage/misc/#virtual-pixel Virtual pixel details} at ImageMagick docs.\r\n * @tutorial 02.05.virtual-pixels-and-matte\r\n */\r\nconst vpx = {\r\n  /**\r\n   * Use image background color.\r\n   */\r\n  BACKGROUND: 1,\r\n\r\n  /**\r\n   * Closest edge color.\r\n   */\r\n  EDGE: 3,\r\n\r\n  /**\r\n   * Mirror effect.\r\n   */\r\n  MIRROR: 4,\r\n\r\n  /**\r\n   * Random color from image.\r\n   */\r\n  RANDOM: 5,\r\n\r\n  /**\r\n   * Tile effect.\r\n   */\r\n  TILE: 6,\r\n\r\n  /**\r\n   * Transparent color.\r\n   */\r\n  TRANSPARENT: 7,\r\n\r\n  /**\r\n   * Black color.\r\n   */\r\n  BLACK: 9,\r\n\r\n  /**\r\n   * Gray color.\r\n   */\r\n  GRAY: 10,\r\n\r\n  /**\r\n   * White color.\r\n   */\r\n  WHITE: 11,\r\n\r\n  /**\r\n   * Tile effect horizontally, background color vertically.\r\n   */\r\n  HORIZONTAL_TILE: 12,\r\n\r\n  /**\r\n   * Tile effect vertically, background color horizontally.\r\n   */\r\n  VERTICAL_TILE: 13,\r\n\r\n  /**\r\n   * Tile effect horizontally, closest edge color vertically.\r\n   */\r\n  HORIZONTAL_TILE_EDGE: 14,\r\n\r\n  /**\r\n   * Tile effect vertically, closest edge color horizontally.\r\n   */\r\n  VERTICAL_TILE_EDGE: 15\r\n\r\n  // TODO: implement and add Checker tile an dither methods\r\n};\r\n\r\nexport default vpx;","/**\r\n * Color interpolation methods.\r\n *\r\n * @readonly\r\n * @enum {number}\r\n * @memberof lens\r\n */\r\nconst interpolation = {\r\n  /**\r\n   * Average 4 nearest neighbours.\r\n   */\r\n  AVERAGE: 1,\r\n\r\n  /**\r\n   * Average 9 nearest neighbours.\r\n   */\r\n  AVERAGE_9: 2,\r\n\r\n  /**\r\n   * Average 16 nearest neighbours.\r\n   */\r\n  AVERAGE_16: 3,\r\n\r\n  /**\r\n   * Just return background color.\r\n   */\r\n  BACKGROUND: 4,\r\n\r\n  /**\r\n   * Integer (floor) interpolation.\r\n   */\r\n  INTEGER: 8 // TODO: implement and add other methods\r\n};\r\n\r\nexport default interpolation;","import vpx from '../vpx';\r\nimport interpolation from '../interpolation';\r\nimport {MAXIMUM_VALUE} from \"../constants\";\r\nimport {blendColors} from \"../util/util\";\r\n\r\n/**\r\n * @private\r\n * @type {number}\r\n */\r\nconst WEIGHT_LOOKUP_TABLE_WIDTH = 1024;\r\n\r\n/**\r\n * @private\r\n * @param {FilterInterface} filter\r\n * @param {number} support\r\n * @returns {number[]}\r\n */\r\nfunction buildWeightLookupTable(filter, support) {\r\n  const table = [];\r\n\r\n  const rScale = support * Math.sqrt(1 / WEIGHT_LOOKUP_TABLE_WIDTH);\r\n\r\n  for (let Q = 0; Q < WEIGHT_LOOKUP_TABLE_WIDTH; Q++) {\r\n    table[Q] = filter.getWeight(Math.sqrt(Q) * rScale);\r\n  }\r\n\r\n  return table;\r\n}\r\n\r\n/**\r\n * @private\r\n * @param value\r\n * @param quantumRange\r\n * @returns {number}\r\n */\r\nfunction clampToQuantum(value, quantumRange) {\r\n  return Math.max(0, Math.min(quantumRange, value));\r\n}\r\n\r\n/**\r\n * <p>ClampEllipseAxes() function converts the input vectors into a major and\r\n * minor axis unit vectors, and their magnitude.  This allows us to\r\n * ensure that the ellipse generated is never smaller than the unit\r\n * circle and thus never too small for use in EWA resampling.</p>\r\n *\r\n * <p>This purely mathematical 'magic' was provided by Professor Nicolas\r\n * Robidoux and his Masters student Chantal Racette.</p>\r\n *\r\n * <p>Reference: \"We Recommend Singular Value Decomposition\", David Austin\r\n *   {@link http://www.ams.org/samplings/feature-column/fcarc-svd}</p>\r\n *\r\n * <p>By generating major and minor axis vectors, we can actually use the\r\n * ellipse in its \"canonical form\", by remapping the dx,dy of the\r\n * sampled point into distances along the major and minor axis unit\r\n * vectors.</p>\r\n *\r\n * <p>Reference: {@link http://en.wikipedia.org/wiki/Ellipse#Canonical_form}</p>\r\n *\r\n * @private\r\n * @param {number} dux\r\n * @param {number} duy\r\n * @param {number} dvx\r\n * @param {number} dvy\r\n * @returns {number[]}\r\n * @see {@link https://imagemagick.org/api/MagickCore/resample_8c_source.html#l00709 ClampUpAxes() at ImageMagick source}\r\n * @tutorial 02.03.pixel-color-lookup\r\n */\r\nfunction clampEllipseAxes(dux, duy, dvx, dvy) {\r\n  /*\r\n   * ClampUpAxes takes an input 2x2 matrix\r\n   *\r\n   * [ a b ] = [ dux duy ]\r\n   * [ c d ] = [ dvx dvy ]\r\n   *\r\n   * and computes from it the major and minor axis vectors [major_x,\r\n   * major_y] and [minor_x,minor_y] of the smallest ellipse containing\r\n   * both the unit disk and the ellipse which is the image of the unit\r\n   * disk by the linear transformation\r\n   *\r\n   * [ dux duy ] [S] = [s]\r\n   * [ dvx dvy ] [T] = [t]\r\n   *\r\n   * (The vector [S,T] is the difference between a position in output\r\n   * space and [X,Y]; the vector [s,t] is the difference between a\r\n   * position in input space and [x,y].)\r\n   */\r\n  /*\r\n   * Output:\r\n   *\r\n   * major_mag is the half-length of the major axis of the \"new\"\r\n   * ellipse.\r\n   *\r\n   * minor_mag is the half-length of the minor axis of the \"new\"\r\n   * ellipse.\r\n   *\r\n   * major_unit_x is the x-coordinate of the major axis direction vector\r\n   * of both the \"old\" and \"new\" ellipses.\r\n   *\r\n   * major_unit_y is the y-coordinate of the major axis direction vector.\r\n   *\r\n   * minor_unit_x is the x-coordinate of the minor axis direction vector.\r\n   *\r\n   * minor_unit_y is the y-coordinate of the minor axis direction vector.\r\n   *\r\n   * Unit vectors are useful for computing projections, in particular,\r\n   * to compute the distance between a point in output space and the\r\n   * center of a unit disk in output space, using the position of the\r\n   * corresponding point [s,t] in input space. Following the clamping,\r\n   * the square of this distance is\r\n   *\r\n   * ( ( s * major_unit_x + t * major_unit_y ) / major_mag )^2\r\n   * +\r\n   * ( ( s * minor_unit_x + t * minor_unit_y ) / minor_mag )^2\r\n   *\r\n   * If such distances will be computed for many [s,t]'s, it makes\r\n   * sense to actually compute the reciprocal of major_mag and\r\n   * minor_mag and multiply them by the above unit lengths.\r\n   *\r\n   * Now, if you want to modify the input pair of tangent vectors so\r\n   * that it defines the modified ellipse, all you have to do is set\r\n   *\r\n   * newdux = major_mag * major_unit_x\r\n   * newdvx = major_mag * major_unit_y\r\n   * newduy = minor_mag * minor_unit_x = minor_mag * -major_unit_y\r\n   * newdvy = minor_mag * minor_unit_y = minor_mag *  major_unit_x\r\n   *\r\n   * and use these tangent vectors as if they were the original ones.\r\n   * Usually, this is a drastic change in the tangent vectors even if\r\n   * the singular values are not clamped; for example, the minor axis\r\n   * vector always points in a direction which is 90 degrees\r\n   * counterclockwise from the direction of the major axis vector.\r\n   */\r\n  /*\r\n   * Discussion:\r\n   *\r\n   * GOAL: Fix things so that the pullback, in input space, of a disk\r\n   * of radius r in output space is an ellipse which contains, at\r\n   * least, a disc of radius r. (Make this hold for any r>0.)\r\n   *\r\n   * ESSENCE OF THE METHOD: Compute the product of the first two\r\n   * factors of an SVD of the linear transformation defining the\r\n   * ellipse and make sure that both its columns have norm at least 1.\r\n   * Because rotations and reflexions map disks to themselves, it is\r\n   * not necessary to compute the third (rightmost) factor of the SVD.\r\n   *\r\n   * DETAILS: Find the singular values and (unit) left singular\r\n   * vectors of Jinv, clampling up the singular values to 1, and\r\n   * multiply the unit left singular vectors by the new singular\r\n   * values in order to get the minor and major ellipse axis vectors.\r\n   *\r\n   * Image resampling context:\r\n   *\r\n   * The Jacobian matrix of the transformation at the output point\r\n   * under consideration is defined as follows:\r\n   *\r\n   * Consider the transformation (x,y) -> (X,Y) from input locations\r\n   * to output locations. (Anthony Thyssen, elsewhere in resample.c,\r\n   * uses the notation (u,v) -> (x,y).)\r\n   *\r\n   * The Jacobian matrix of the transformation at (x,y) is equal to\r\n   *\r\n   *   J = [ A, B ] = [ dX/dx, dX/dy ]\r\n   *       [ C, D ]   [ dY/dx, dY/dy ]\r\n   *\r\n   * that is, the vector [A,C] is the tangent vector corresponding to\r\n   * input changes in the horizontal direction, and the vector [B,D]\r\n   * is the tangent vector corresponding to input changes in the\r\n   * vertical direction.\r\n   *\r\n   * In the context of resampling, it is natural to use the inverse\r\n   * Jacobian matrix Jinv because resampling is generally performed by\r\n   * pulling pixel locations in the output image back to locations in\r\n   * the input image. Jinv is\r\n   *\r\n   *   Jinv = [ a, b ] = [ dx/dX, dx/dY ]\r\n   *          [ c, d ]   [ dy/dX, dy/dY ]\r\n   *\r\n   * Note: Jinv can be computed from J with the following matrix\r\n   * formula:\r\n   *\r\n   *   Jinv = 1/(A*D-B*C) [  D, -B ]\r\n   *                      [ -C,  A ]\r\n   *\r\n   * What we do is modify Jinv so that it generates an ellipse which\r\n   * is as close as possible to the original but which contains the\r\n   * unit disk. This can be accomplished as follows:\r\n   *\r\n   * Let\r\n   *\r\n   *   Jinv = U Sigma V^T\r\n   *\r\n   * be an SVD decomposition of Jinv. (The SVD is not unique, but the\r\n   * final ellipse does not depend on the particular SVD.)\r\n   *\r\n   * We could clamp up the entries of the diagonal matrix Sigma so\r\n   * that they are at least 1, and then set\r\n   *\r\n   *   Jinv = U newSigma V^T.\r\n   *\r\n   * However, we do not need to compute V for the following reason:\r\n   * V^T is an orthogonal matrix (that is, it represents a combination\r\n   * of rotations and reflexions) so that it maps the unit circle to\r\n   * itself. For this reason, the exact value of V does not affect the\r\n   * final ellipse, and we can choose V to be the identity\r\n   * matrix. This gives\r\n   *\r\n   *   Jinv = U newSigma.\r\n   *\r\n   * In the end, we return the two diagonal entries of newSigma\r\n   * together with the two columns of U.\r\n   */\r\n  /*\r\n   * ClampUpAxes was written by Nicolas Robidoux and Chantal Racette\r\n   * of Laurentian University with insightful suggestions from Anthony\r\n   * Thyssen and funding from the National Science and Engineering\r\n   * Research Council of Canada. It is distinguished from its\r\n   * predecessors by its efficient handling of degenerate cases.\r\n   *\r\n   * The idea of clamping up the EWA ellipse's major and minor axes so\r\n   * that the result contains the reconstruction kernel filter support\r\n   * is taken from Andreas Gustaffson's Masters thesis \"Interactive\r\n   * Image Warping\", Helsinki University of Technology, Faculty of\r\n   * Information Technology, 59 pages, 1993 (see Section 3.6).\r\n   *\r\n   * The use of the SVD to clamp up the singular values of the\r\n   * Jacobian matrix of the pullback transformation for EWA resampling\r\n   * is taken from the astrophysicist Craig DeForest.  It is\r\n   * implemented in his PDL::Transform code (PDL = Perl Data\r\n   * Language).\r\n   */\r\n\r\n  const a = dux;\r\n  const b = duy;\r\n  const c = dvx;\r\n  const d = dvy;\r\n\r\n  /*\r\n   * n is the matrix Jinv * transpose(Jinv). Eigenvalues of n are the\r\n   * squares of the singular values of Jinv.\r\n   */\r\n  const aa = a * a;\r\n  const bb = b * b;\r\n  const cc = c * c;\r\n  const dd = d * d;\r\n\r\n  /*\r\n   * Eigenvectors of n are left singular vectors of Jinv.\r\n   */\r\n  const n11 = aa + bb;\r\n  const n12 = a * c + b * d;\r\n  const n21 = n12;\r\n  const n22 = cc + dd;\r\n  const det = a * d - b * c;\r\n  const twice_det = det + det;\r\n  const frobenius_squared = n11 + n22;\r\n  const discriminant = (frobenius_squared + twice_det) * (frobenius_squared - twice_det);\r\n\r\n  /*\r\n   * In exact arithmetic, discriminant can't be negative. In floating\r\n   * point, it can, because of the bad conditioning of SVD\r\n   * decompositions done through the associated normal matrix.\r\n   */\r\n  const sqrt_discriminant = Math.sqrt(discriminant > 0 ? discriminant : 0);\r\n\r\n  /*\r\n   * s1 is the largest singular value of the inverse Jacobian\r\n   * matrix. In other words, its reciprocal is the smallest singular\r\n   * value of the Jacobian matrix itself.\r\n   * If s1 = 0, both singular values are 0, and any orthogonal pair of\r\n   * left and right factors produces a singular decomposition of Jinv.\r\n   */\r\n  /*\r\n   * Initially, we only compute the squares of the singular values.\r\n   */\r\n  const s1s1 = 0.5 * (frobenius_squared + sqrt_discriminant);\r\n\r\n  /*\r\n   * s2 the smallest singular value of the inverse Jacobian\r\n   * matrix. Its reciprocal is the largest singular value of the\r\n   * Jacobian matrix itself.\r\n   */\r\n  const s2s2 = 0.5 * (frobenius_squared - sqrt_discriminant);\r\n  const s1s1minusn11 = s1s1 - n11;\r\n  const s1s1minusn22 = s1s1 - n22;\r\n\r\n  /*\r\n   * u1, the first column of the U factor of a singular decomposition\r\n   * of Jinv, is a (non-normalized) left singular vector corresponding\r\n   * to s1. It has entries u11 and u21. We compute u1 from the fact\r\n   * that it is an eigenvector of n corresponding to the eigenvalue\r\n   * s1^2.\r\n   */\r\n  const s1s1minusn11_squared = s1s1minusn11 * s1s1minusn11;\r\n  const s1s1minusn22_squared = s1s1minusn22 * s1s1minusn22;\r\n\r\n  /*\r\n   * The following selects the largest row of n-s1^2 I as the one\r\n   * which is used to find the eigenvector. If both s1^2-n11 and\r\n   * s1^2-n22 are zero, n-s1^2 I is the zero matrix.  In that case,\r\n   * any vector is an eigenvector; in addition, norm below is equal to\r\n   * zero, and, in exact arithmetic, this is the only case in which\r\n   * norm = 0. So, setting u1 to the simple but arbitrary vector [1,0]\r\n   * if norm = 0 safely takes care of all cases.\r\n   */\r\n  const temp_u11 = (s1s1minusn11_squared >= s1s1minusn22_squared) ? n12 : s1s1minusn22;\r\n  const temp_u21 = (s1s1minusn11_squared >= s1s1minusn22_squared) ? s1s1minusn11 : n21;\r\n  const norm = Math.sqrt(temp_u11 * temp_u11 + temp_u21 * temp_u21);\r\n\r\n  /*\r\n   * Finalize the entries of first left singular vector (associated\r\n   * with the largest singular value).\r\n   */\r\n  const u11 = norm > 0 ? temp_u11 / norm : 1;\r\n  const u21 = norm > 0 ? temp_u21 / norm : 0;\r\n\r\n  /*\r\n   * Clamp the singular values up to 1.\r\n   */\r\n  const major_mag = s1s1 <= 1 ? 1 : Math.sqrt(s1s1);\r\n  const minor_mag = s2s2 <= 1 ? 1 : Math.sqrt(s2s2);\r\n\r\n\r\n  const major_x = u11 * major_mag;\r\n  const major_y = u21 * major_mag;\r\n  const minor_x = -u21 * minor_mag;\r\n  const minor_y = u11 * minor_mag;\r\n\r\n  return [\r\n    major_x,\r\n    major_y,\r\n    minor_x,\r\n    minor_y,\r\n    major_mag,\r\n    minor_mag\r\n  ];\r\n}\r\n\r\n/**\r\n * Elliptical Weighted Average.\r\n * Resamples pixel color using Elliptical Weighted Average technique.\r\n *\r\n * @implements {ResamplerInterface}\r\n * @memberOf lens.resampler\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#distort_ewa EWA details} at ImageMagick docs.\r\n * @see {@link https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf Fundamentals of Texture Mapping and Image Warping by Paul S. Heckbert}\r\n * page 41, section 3.4, 3.5\r\n * @see {@link https://imagemagick.org/api/MagickCore/resample_8c_source.html#l01038 ScaleResampleFilter()} at\r\n * ImageMagick source.\r\n * @see {@link https://imagemagick.org/api/MagickCore/resample_8c_source.html#l00315 ResamplePixelColor()} at\r\n * ImageMagick source.\r\n */\r\nclass EWA {\r\n\r\n  /**\r\n   *\r\n   * @param {FilterInterface} filter\r\n   */\r\n  constructor(filter) {\r\n    /**\r\n     * Reconstruction filter.\r\n     * @protected\r\n     * @type {FilterInterface}\r\n     */\r\n    this.resizeFilter = filter;\r\n\r\n    /**\r\n     * The practical working support of the filter\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.support = this.resizeFilter.support * this.resizeFilter.blur;\r\n\r\n    /**\r\n     * Matte color for invalid mappings.\r\n     * @type {Color}\r\n     */\r\n    this.matteColor = [0, 0, 0, 0];\r\n\r\n    /**\r\n     * Lookup table of weights for filtered average in elliptical area.\r\n     * @protected\r\n     * @type {number[]}\r\n     */\r\n    this.weightLookupTable = buildWeightLookupTable(this.resizeFilter, this.support);\r\n\r\n    /**\r\n     * Image being resampled.\r\n     * @type {ImageInterface}\r\n     */\r\n    this.image = null;\r\n\r\n    /**\r\n     * Distortion mapper.\r\n     * @protected\r\n     * @type {DistortionInterface}\r\n     */\r\n    this.mapper = null;\r\n\r\n    /**\r\n     * Cached for direct access image virtual viewport.\r\n     * @protected\r\n     * @type {lens.Viewport}\r\n     */\r\n    this.imageViewport = null;\r\n\r\n    /**\r\n     * Cached image area.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.imageArea = null;\r\n\r\n    /**\r\n     * Cached for direct access image virtual pixel method.\r\n     * @protected\r\n     * @type {lens.vpx}\r\n     */\r\n    this.imageVirtualPixelMethod = null;\r\n\r\n    /**\r\n     * Cached image average color.\r\n     * @protected\r\n     * @type {Color|null}\r\n     */\r\n    this.imageAverageColor = null;\r\n\r\n    /**\r\n     * Ellipse equiation A.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.A = 0;\r\n\r\n    /**\r\n     * Ellipse equation B.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.B = 0;\r\n\r\n    /**\r\n     * Ellipse equation C.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.C = 0;\r\n\r\n    /**\r\n     * Ellipse equation F.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.F = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.uLimit = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.vLimit = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.uWidth = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.slope = 0;\r\n\r\n    /**\r\n     * Used for distortions with constant partial derivatives to flag that ellipse already has been set up.\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.ellipseIsSetUp = false;\r\n\r\n    /**\r\n     * Flags that ellipse is too large and it is impractical to resample color -- better use some of possible\r\n     * optimizations.\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.limitReached = false;\r\n\r\n    /**\r\n     * Output image scaling factor.\r\n     * @type {number}\r\n     */\r\n    this.scaling = 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getResampledColor(x, y) {\r\n    x = x * this.scaling;\r\n    y = y * this.scaling;\r\n\r\n    const validity = this.mapper.getValidity(x, y, this.scaling);\r\n\r\n    if (validity > 0) {\r\n      const [u, v] = this.mapper.reverseMap(x, y);\r\n\r\n      if (this.mapper.hasConstantPartialDerivatives) {\r\n        this.setupEllipseOnce(...this.mapper.getPartialDerivatives(x, y));\r\n      } else {\r\n        this.setupEllipse(...this.mapper.getPartialDerivatives(x, y));\r\n      }\r\n\r\n      const color = this.getWeightedAverage(u, v);\r\n\r\n      if (validity < 1) {\r\n        return blendColors(color, validity, this.matteColor);\r\n      }\r\n\r\n      return color;\r\n    }\r\n\r\n    return this.matteColor.slice();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setImage(image) {\r\n    this.image = image;\r\n    // cache image viewport for faster direct access.\r\n    this.imageViewport = this.image.viewport;\r\n    // cache image area.\r\n    this.imageArea = this.imageViewport.area();\r\n    // cache image virtual pixel method (will it be faster actually?)\r\n    this.imageVirtualPixelMethod = this.image.virtualPixelMethod;\r\n    // reset cached image average color\r\n    this.imageAverageColor = null;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setMapper(mapper) {\r\n    if (!mapper.hasPartialDerivatives) {\r\n      throw new Error('Pixel mapper must have partial derivatives to use this resampler');\r\n    }\r\n\r\n    this.mapper = mapper;\r\n    this.ellipseIsSetUp = false;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculates ellipse once for distortions with constant partial derivatives.\r\n   *\r\n   * @private\r\n   * @param derivatives\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  setupEllipseOnce(...derivatives) {\r\n    if (!this.ellipseIsSetUp) {\r\n      this.ellipseIsSetUp = true;\r\n      return this.setupEllipse(...derivatives);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculates ellipse for EWA resampling using partial derivatives.\r\n   *\r\n   * @private\r\n   * @param derivatives\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  setupEllipse(...derivatives) {\r\n    this.limitReached = false;\r\n\r\n    derivatives = derivatives.map(derivative => derivative * this.scaling);\r\n\r\n    return this.initEllipse(...derivatives)\r\n      .scaleEllipse();\r\n  }\r\n\r\n  /**\r\n   * Calculates ellipse equation for given distortion partial derivatives.\r\n   *\r\n   * @private\r\n   * @param derivatives\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  initEllipse(...derivatives) {\r\n    const [\r\n      major_x,\r\n      major_y,\r\n      minor_x,\r\n      minor_y,\r\n      major_mag,\r\n      minor_mag\r\n    ] = clampEllipseAxes(...derivatives);\r\n\r\n    this.A = major_y * major_y + minor_y * minor_y;\r\n    this.B = -2 * (major_x * major_y + minor_x * minor_y);\r\n    this.C = major_x * major_x + minor_x * minor_x;\r\n    this.F = major_mag * minor_mag;\r\n    this.F *= this.F;\r\n\r\n    /*\r\n     * If one or both of the scaling vectors is impossibly large\r\n     * (producing a very large raw F value), we may as well not bother\r\n     * doing any form of resampling since resampled area is very large.\r\n     * In this case some alternative means of pixel sampling, such as\r\n     * the average of the whole image is needed to get a reasonable\r\n     * result. Calculate only as needed.\r\n     */\r\n    this.limitReached = 4 * this.A * this.C - this.B * this.B > MAXIMUM_VALUE;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales ellipse to match filter support.\r\n   *\r\n   * @private\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  scaleEllipse() {\r\n    if (!this.limitReached) {\r\n      this.F *= this.support * this.support;\r\n      this.uLimit = Math.sqrt(this.C * this.F / (this.A * this.C - 0.25 * this.B * this.B));\r\n      this.vLimit = Math.sqrt(this.A * this.F / (this.A * this.C - 0.25 * this.B * this.B));\r\n      this.uWidth = Math.sqrt(this.F / this.A);\r\n      this.slope = -this.B / (2 * this.A);\r\n\r\n      /*\r\n       * Check the absolute area of the parallelogram involved.\r\n       * This limit needs more work, as it is too slow for larger images\r\n       * with tiled views of the horizon.\r\n       */\r\n      if (this.uWidth * this.vLimit > 4 * this.imageArea) {\r\n        this.limitReached = true;\r\n        return this;\r\n      }\r\n\r\n      /* Scale ellipse formula to directly index the Filter Lookup Table */\r\n      const scale = WEIGHT_LOOKUP_TABLE_WIDTH / this.F;\r\n      this.A *= scale;\r\n      this.B *= scale;\r\n      this.C *= scale;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns weighted average color at given point using scaled EWA ellipse.\r\n   *\r\n   * @private\r\n   * @param {number} u0\r\n   * @param {number} v0\r\n   * @returns {Color}\r\n   */\r\n  getWeightedAverage(u0, v0) {\r\n    if (this.doesntNeedResampling(u0, v0)) {\r\n      /* The area being resampled is simply a solid color\r\n       * just return a single lookup color.\r\n       */\r\n      return this.image.getPixelColor(u0, v0);\r\n    }\r\n\r\n    if (this.limitReached) {\r\n      // When Scaling limits reached, return an 'averaged' result.\r\n\r\n      switch (this.imageVirtualPixelMethod) {\r\n        case vpx.EDGE:\r\n        case vpx.HORIZONTAL_TILE_EDGE:\r\n        case vpx.VERTICAL_TILE_EDGE:\r\n          /*\r\n           * We need an average edge pixel, from the correct edge!\r\n           * How should I calculate an average edge color?\r\n           * Just returning an averaged neighbourhood,\r\n           * works well in general, but falls down for TileEdge methods.\r\n           * This needs to be done properly!!!!!!\r\n           */\r\n          return this.image.getInterpolatedPixelColor(u0, v0, interpolation.AVERAGE);\r\n        case vpx.HORIZONTAL_TILE:\r\n        case vpx.VERTICAL_TILE:\r\n          /*\r\n          * just return the background pixel - Is there more direct way?\r\n          */\r\n          return this.image.getPixelColor(\r\n            this.imageViewport.x1 - 1,\r\n            this.imageViewport.y1 - 1\r\n          );\r\n        default:\r\n          return this.getImageAverageColor();\r\n      }\r\n    }\r\n\r\n    let divisorM = 0,\r\n      divisorC = 0,\r\n      red = 0,\r\n      green = 0,\r\n      blue = 0,\r\n      alpha = 0;\r\n\r\n    /*\r\n     * Determine the parellelogram bounding box fitted to the ellipse\r\n     * centered at u0,v0.  This area is bounding by the lines...\r\n     */\r\n    const v1 = Math.ceil(v0 - this.vLimit);\r\n    const v2 = Math.floor(v0 + this.vLimit);\r\n\r\n    // scan line start and width accross the parallelogram\r\n    let u1 = u0 + (v1 - v0) * this.slope - this.uWidth;\r\n    let uw = 2 * this.uWidth + 1;\r\n\r\n    /*\r\n     * Do weighted resampling of all pixels,  within the scaled ellipse,\r\n     * bound by a Parellelogram fitted to the ellipse.\r\n     */\r\n\r\n    let DDQ = 2 * this.A;\r\n\r\n    for (let v = v1; v < v2; v++) {\r\n      let ustart = Math.ceil(u1); // first pixel in scanline\r\n      u1 += this.slope; // start of next scan line\r\n      let uend = ustart + uw;\r\n\r\n      // location of this first pixel, relative to u0,v0\r\n      let U = ustart - u0;\r\n      let V = v - v0;\r\n\r\n      // Q = ellipse quotent ( if Q<F then pixel is inside ellipse)\r\n      let Q = (this.A * U + this.B * V) * U + this.C * V * V;\r\n      let DQ = this.A * (2 * U + 1) + this.B * V;\r\n\r\n      // count up the weighted pixel colors\r\n      for (let u = ustart; u < uend; u++) {\r\n        // Note that the ellipse has been pre-scaled so F = $this->weightLookupTableWidth\r\n        if (Q < WEIGHT_LOOKUP_TABLE_WIDTH) {\r\n          let weight = this.weightLookupTable[Math.floor(Q)];\r\n          let [r, g, b, a] = this.image.getPixelColor(u, v);\r\n          alpha += weight * a;\r\n          divisorM += weight;\r\n\r\n          weight *= (a / this.image.quantumRange);\r\n\r\n          red += r * weight;\r\n          green += g * weight;\r\n          blue += b * weight;\r\n          divisorC += weight;\r\n        }\r\n\r\n        Q += DQ;\r\n        DQ += DDQ;\r\n      }\r\n    }\r\n\r\n    // Result sanity check -- this should NOT happen\r\n    if (!divisorC || !divisorM) {\r\n      /*\r\n       * not enough pixels, or bad weighting in resampling,\r\n       * resort to direct interpolation\r\n       */\r\n      return this.image.getInterpolatedPixelColor(u0, v0);\r\n    }\r\n\r\n    return [\r\n      clampToQuantum(Math.round(red / divisorC), this.image.quantumRange),\r\n      clampToQuantum(Math.round(green / divisorC), this.image.quantumRange),\r\n      clampToQuantum(Math.round(blue / divisorC), this.image.quantumRange),\r\n      clampToQuantum(Math.round(alpha / divisorM), this.image.quantumRange)\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Checks if no resampling is needed (if single pixel color should be returned).\r\n   *\r\n   * @private\r\n   * @param {number} u\r\n   * @param {number} v\r\n   * @returns {boolean}\r\n   */\r\n  doesntNeedResampling(u, v) {\r\n    switch (this.imageVirtualPixelMethod) {\r\n      case vpx.TRANSPARENT:\r\n      case vpx.BACKGROUND:\r\n      case vpx.BLACK:\r\n      case vpx.WHITE:\r\n      case vpx.GRAY:\r\n        return this.limitReached || this.outOfImageBounds(u, v);\r\n      case vpx.EDGE:\r\n        return (u + this.uLimit < this.imageViewport.x1 && v + this.vLimit < this.imageViewport.y1) ||\r\n          (u + this.uLimit < this.imageViewport.x1 && v - this.vLimit > this.imageViewport.y2) ||\r\n          (u - this.uLimit > this.imageViewport.x2 && v + this.vLimit < this.imageViewport.y1) ||\r\n          (u - this.uLimit > this.imageViewport.x2 && v - this.vLimit > this.imageViewport.y2);\r\n      case vpx.HORIZONTAL_TILE:\r\n        return v + this.vLimit < this.imageViewport.y1 || v - this.vLimit > this.imageViewport.y2;\r\n      case vpx.VERTICAL_TILE:\r\n        return u + this.uLimit < this.imageViewport.x1 || u - this.uLimit > this.imageViewport.x2;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Laziliy returns cached image average color.\r\n   *\r\n   * @private\r\n   * @returns {Color}\r\n   */\r\n  getImageAverageColor() {\r\n    if (this.imageAverageColor === null) {\r\n      this.imageAverageColor = this.image.getAverageColor();\r\n    }\r\n\r\n    return this.imageAverageColor.slice();\r\n  }\r\n\r\n  /**\r\n   * Checks if ellipse is completely out of image bounds.\r\n   *\r\n   * @private\r\n   * @param {number} u\r\n   * @param {number} v\r\n   * @returns {boolean}\r\n   */\r\n  outOfImageBounds(u, v) {\r\n    return u + this.uLimit < this.imageViewport.x1 ||\r\n      u - this.uLimit > this.imageViewport.x2 ||\r\n      v + this.vLimit < this.imageViewport.y1 ||\r\n      v - this.vLimit > this.imageViewport.y2;\r\n  }\r\n}\r\n\r\nexport default EWA;","import {EPSILON} from \"../constants\";\r\n\r\n/**\r\n * Internal filter or windowing function.\r\n *\r\n * @callback lens.filter.Filter~filterFunction\r\n * @param {number} [x]\r\n * @param {number} [support]\r\n * @param {number} [windowSupport]\r\n * @returns {number}\r\n */\r\n\r\n/**\r\n * Resample filter.\r\n *\r\n * @implements {FilterInterface}\r\n * @memberOf lens.filter\r\n * @see {@link https://www.imagemagick.org/Usage/filter/#filter Resampling Filters} at ImageMagick docs\r\n * @see {@link https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf Fundamentals of Texture Mapping and Image Warping by Paul S. Heckbert}\r\n * page 41, section 3.4, 3.5\r\n * @see {@link https://imagemagick.org/api/MagickCore/resize_8c_source.html#l00757 AquireResizeFilter at ImageMagick source}\r\n * @tutorial 02.03.pixel-color-lookup\r\n */\r\nclass Filter {\r\n\r\n  /**\r\n   *\r\n   * @param {lens.filter.Filter~filterFunction} filterFunction Filtering function.\r\n   * @param {lens.filter.Filter~filterFunction} windowingFunction Windowing function.\r\n   * @param {number} support Filter region of support - the filter support limit.\r\n   * @param {number} scale Dimension scaling to fit window support (usally 1.0).\r\n   * @param {number} [blur=1] X-scale (blur-sharpen).\r\n   * @param {number|null} [windowSupport=null] Window support, usually equal to support (expert only).\r\n   */\r\n  constructor(filterFunction, windowingFunction, support, scale, blur = 1, windowSupport = null) {\r\n    this.filterFunction    = filterFunction;\r\n    this.windowingFunction = windowingFunction;\r\n    this.support           = support;\r\n    this.scale             = scale;\r\n    this.blur              = blur;\r\n    this.windowSupport     = windowSupport !== null ? windowSupport : support;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getWeight(x) {\r\n    const xBlur = x / this.blur;\r\n    const scale = xBlur < EPSILON ? 1 : this.window(this.scale * xBlur);\r\n    return scale * this.filter(xBlur);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  filter(x) {\r\n    return this.filterFunction(x, this.support, this.windowSupport);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  window(x) {\r\n    return this.windowingFunction(x, this.support, this.windowSupport);\r\n  }\r\n}\r\n\r\nexport default Filter;","/**\r\n * @namespace lens.filter.filterFunctions\r\n */\r\n\r\n/**\r\n * Makes box filter function.\r\n * A Box filter is a equal weighting function (all weights equal).\r\n * DO NOT LIMIT results by support or resize point sampling will work\r\n * as it requests points beyond its normal 0.0 support size.\r\n *\r\n * @memberOf lens.filter.filterFuncFactories\r\n * @returns {lens.filter.Filter~filterFunction}\r\n * @see {@link https://imagemagick.org/api/MagickCore/resize_8c_source.html#l00181 Ox filter function at ImageMagick source}\r\n */\r\nfunction box() {\r\n  const func = function () {\r\n    return 1;\r\n  };\r\n\r\n  func.filterFunctionName = 'box';\r\n\r\n  return func;\r\n}\r\n\r\n/**\r\n * Makes cubicBC filter function.\r\n * <p>Cubic Filters using B,C determined values:</p>\r\n * <pre>\r\n *     Mitchell-Netravali  B = 1/3 C = 1/3  \"Balanced\" cubic spline filter\r\n *     Catmull-Rom         B = 0   C = 1/2  Interpolatory and exact on linears\r\n *     Spline              B = 1   C = 0    B-Spline Gaussian approximation\r\n *     Hermite             B = 0   C = 0    B-Spline interpolator\r\n * </pre>\r\n *\r\n * <p>See paper by Mitchell and Netravali, Reconstruction Filters in Computer\r\n * Graphics Computer Graphics, Volume 22, Number 4, August 1988\r\n * {@link http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf}.</p>\r\n *\r\n * <p>Coefficents are determined from B,C values:\r\n * <pre>\r\n *    P0 = (  6 - 2*B       )/6 = coeff[0]\r\n *    P1 =         0\r\n *    P2 = (-18 +12*B + 6*C )/6 = coeff[1]\r\n *    P3 = ( 12 - 9*B - 6*C )/6 = coeff[2]\r\n *    Q0 = (      8*B +24*C )/6 = coeff[3]\r\n *    Q1 = (    -12*B -48*C )/6 = coeff[4]\r\n *    Q2 = (      6*B +30*C )/6 = coeff[5]\r\n *    Q3 = (    - 1*B - 6*C )/6 = coeff[6]\r\n * </pre>\r\n * which are used to define the filter:\r\n * <pre>\r\n *    P0 + P1*x + P2*x^2 + P3*x^3      0 <= x < 1\r\n *    Q0 + Q1*x + Q2*x^2 + Q3*x^3      1 <= x < 2\r\n * </pre>\r\n * which ensures function is continuous in value and derivative (slope).</p>\r\n *\r\n * @memberOf lens.filter.filterFuncFactories\r\n * @see {@link https://imagemagick.org/api/MagickCore/resize_8c_source.html#l00207 CubicBC filter function at ImageMagick source}\r\n * @param {number} b\r\n * @param {number} c\r\n * @returns {lens.filter.Filter~filterFunction}\r\n */\r\nfunction cubicBC(b, c) {\r\n  const p0 = (6 - 2 * b) / 6;\r\n  // const p1 = 0;\r\n  const p2 = (-18 + 12 * b + 6 * c) / 6;\r\n  const p3 = (12 - 9 * b - 6 * c) / 6;\r\n  const q0 = (8 * b + 24 * c) / 6;\r\n  const q1 = (-12 * b - 48 * c) / 6;\r\n  const q2 = (6 * b + 30 * c) / 6;\r\n  const q3 = (-1 * b - 6 * c) / 6;\r\n\r\n  const func = function (x) {\r\n    if (x < 1) {\r\n      return p0 + x * (x * (p2 + x * p3));\r\n    } else if (x < 2) {\r\n      return q0 + x * (q1 + x * (q2 + x * q3));\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  func.filterFunctionName = 'cubicBC';\r\n  func.b = b;\r\n  func.c = c;\r\n\r\n  return func;\r\n};\r\n\r\n// TODO: add more filter functions\r\n\r\nexport {\r\n  box, cubicBC\r\n};","import Filter from './filter/filter';\r\nimport {box, cubicBC} from \"./filter/filter-functions\";\r\n\r\n/**\r\n * Filter factory.\r\n *\r\n * @callback lens~filterFactory\r\n * @returns {FilterInterface}\r\n */\r\n\r\n/**\r\n * @private\r\n * @returns {lens.filter.Filter}\r\n * @constructor\r\n */\r\nfunction ROBIDOUX() {\r\n  return new Filter(\r\n    cubicBC(0.37821575509399867, 0.31089212245300067),\r\n    box(),\r\n    2,\r\n    1.1685777620836932,\r\n    1\r\n  );\r\n}\r\n\r\n/**\r\n * @private\r\n * @returns {lens.filter.Filter}\r\n * @constructor\r\n */\r\nfunction ROBIDOUX_SHARP() {\r\n  return new Filter(\r\n    cubicBC(0.2620145123990142, 0.3689927438004929),\r\n    box(),\r\n    2,\r\n    1.105822933719019,\r\n    1\r\n  );\r\n}\r\n\r\n/**\r\n * Filter presets.\r\n *\r\n * @enum {lens~filterFactory}\r\n * @memberOf lens\r\n */\r\nconst filterPresets = {\r\n  ROBIDOUX,\r\n  ROBIDOUX_SHARP\r\n};\r\n\r\n// TODO add more filter presets\r\n\r\nexport default filterPresets;","import * as distorter from \"./distorter\";\r\nimport * as resampler from \"./resampler\";\r\nimport filterPresets from './filter-presets';\r\n\r\nlet defaultOptions = {\r\n  bestFit: false,\r\n  filter: filterPresets.ROBIDOUX,\r\n  resample: true,\r\n  async: true,\r\n  outputScaling: 1\r\n};\r\n\r\n/**\r\n * @function\r\n * @name distort\r\n * @memberOf lens\r\n * @variation 2\r\n *\r\n * @param {ImageInterface} image\r\n * @param {DistortionInterface} distortion\r\n * @param {DistortionOptions} options\r\n *\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\n\r\n/**\r\n * Performs distortion of image\r\n *\r\n * @memberOf lens\r\n * @param {ImageInterface} image\r\n * @param {lens.distorts|lens~distortionResolver} distortion\r\n * @param {array} args\r\n * @param {DistortionOptions} [options]\r\n *\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\nfunction distort(image, distortion, args, options = {}) {\r\n  try {\r\n    if (typeof distortion === 'function') {\r\n      distortion  = distortion(args, image);\r\n    } else {\r\n      options     = args || {};\r\n    }\r\n\r\n    options = makeOptions(options);\r\n\r\n    if (distortion.forceBestFit) {\r\n      options.bestFit = true;\r\n    }\r\n\r\n    let distorted = sync(\r\n      makeDistorter(\r\n        image,\r\n        distortion,\r\n        makeResampler(image, distortion, options),\r\n        options\r\n      ).distort()\r\n    );\r\n\r\n    if (options.supersample && options.supersample !== 1) {\r\n      return scaleSupersampled(distorted, 1 / options.supersample);\r\n    }\r\n\r\n    return distorted;\r\n  } catch (e) {\r\n    if (options && options.async) {\r\n      return Promise.reject(e);\r\n    }\r\n\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * Sync ImageInterface internal data storage with image object.\r\n *\r\n * @private\r\n * @param {ImageInterface|Promise<ImageInterface>} distorted\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\nfunction sync(distorted) {\r\n  if (distorted instanceof Promise) {\r\n    return distorted.then(distorted => sync(distorted));\r\n  }\r\n\r\n  if ('sync' in distorted && typeof distorted.sync === 'function') {\r\n    return distorted.sync();\r\n  }\r\n\r\n  return distorted;\r\n}\r\n\r\n/**\r\n * Scales supersampled image back to normal size.\r\n *\r\n * @private\r\n * @param {ImageInterface|Promise<ImageInterface>} supersampled\r\n * @param {number} scale\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\nfunction scaleSupersampled(supersampled, scale) {\r\n  if (supersampled instanceof Promise) {\r\n    return supersampled.then(supersampled => scaleSupersampled(supersampled, scale));\r\n  }\r\n\r\n  if ('scale' in supersampled && typeof supersampled.scale === 'function') {\r\n    return supersampled.scale(scale);\r\n  } else {\r\n    console.warn(`Method 'scale()' not found in image object. No scaling performed.`);\r\n  }\r\n\r\n  return supersampled;\r\n}\r\n\r\n/**\r\n * Makes valid options for distortion\r\n *\r\n * @private\r\n * @param {DistortionOptions} options\r\n * @returns {DistortionOptions}\r\n */\r\nfunction makeOptions(options) {\r\n  options = Object.assign({}, defaultOptions, options);\r\n\r\n  if (options.supersample) {\r\n    options.outputScaling = options.supersample;\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\n/**\r\n * Makes image distorter\r\n *\r\n * @private\r\n * @param {ImageInterface} image\r\n * @param {DistortionInterface} distortion\r\n * @param {ResamplerInterface} resampler\r\n * @param {DistortionOptions} options\r\n * @returns {ReversePixelMapping}\r\n */\r\nfunction makeDistorter(image, distortion, resampler, options) {\r\n  const dist = new distorter.ReversePixelMapping(image, distortion, resampler);\r\n  dist.async = !!options.async;\r\n  dist.bestFit = !!options.bestFit;\r\n\r\n  if (options.viewport) {\r\n    dist.viewport = options.viewport;\r\n  }\r\n\r\n  if (options.outputScaling) {\r\n    dist.outputScaling = options.outputScaling;\r\n\r\n    if (options.supersample) {\r\n      dist.supersample = true;\r\n    }\r\n  }\r\n\r\n  return dist;\r\n}\r\n\r\n/**\r\n * Makes resampler\r\n *\r\n * @private\r\n * @param {ImageInterface} image\r\n * @param {DistortionInterface} distortion\r\n * @param {DistortionOptions} options\r\n * @returns {ResamplerInterface}\r\n */\r\nfunction makeResampler(image, distortion, options) {\r\n  let rsm;\r\n\r\n  if (options.resampler) {\r\n    rsm = options.resampler;\r\n  } else if (options.resample) {\r\n    rsm = new resampler.EWA(makeFilter(options));\r\n  } else {\r\n    rsm = new resampler.Point();\r\n  }\r\n\r\n  if (options.matteColor) {\r\n    rsm.matteColor = options.matteColor.slice();\r\n  }\r\n\r\n  return rsm;\r\n}\r\n\r\n/**\r\n * Makes filter\r\n *\r\n * @private\r\n * @param {DistortionOptions} options\r\n * @returns {FilterInterface}\r\n */\r\nfunction makeFilter(options) {\r\n  if (typeof options.filter === 'function') {\r\n    return options.filter();\r\n  }\r\n\r\n  return options.filter;\r\n}\r\n\r\nexport default distort;","/**\r\n * Base Lens exception\r\n *\r\n * @extends Error\r\n * @memberOf lens.exception\r\n */\r\nclass LensException extends Error {\r\n\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'LensException';\r\n\r\n    if (typeof Error.captureStackTrace === 'function') {\r\n      Error.captureStackTrace(this, this.constructor);\r\n    } else {\r\n      this.stack = (new Error(message)).stack;\r\n    }\r\n  }\r\n}\r\n\r\nexport default LensException;","import LensException from './lens-exception';\r\n\r\n/**\r\n * Exception for unsolvable matrix in Gauss-Jordan elimination\r\n *\r\n * @extends lens.exception.LensException\r\n * @memberOf lens.exception\r\n */\r\nclass UnsolvableMatrix extends LensException {\r\n\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'UnsolvableMatrix';\r\n  }\r\n}\r\n\r\nexport default UnsolvableMatrix;","import UnsolvableMatrix from '../../exception/unsolvable-matrix';\r\nimport {perceptibleReciprocal} from \"../util\";\r\n\r\n/**\r\n * @private\r\n * @param {Array} array\r\n * @param {number} row1\r\n * @param {number} col1\r\n * @param {number} row2\r\n * @param {number} col2\r\n */\r\nfunction swap(array, row1, col1, row2, col2) {\r\n  if (array[row1][col1] !== array[row2][col2]) {\r\n    array[row1][col1] += array[row2][col2];\r\n    array[row2][col2] = array[row1][col1] - array[row2][col2];\r\n    array[row1][col1] -= array[row2][col2];\r\n  }\r\n}\r\n\r\nfunction unsolvable() {\r\n  throw new UnsolvableMatrix(\"Can't solve given matrix using Gauss-Jordan method\");\r\n}\r\n\r\n/**\r\n * @summary Solves system of equations using Gauss-Jordan elimination.\r\n *\r\n * @description <p>Brings the matrix to reduced row echelon form,\r\n *  while simultaneously reducing and thus solving the augmented results\r\n *  matrix.</p>\r\n *\r\n * <p>See also {@link http://en.wikipedia.org/wiki/Gauss-Jordan_elimination}</p>\r\n *\r\n *\r\n *  <p>Note that the 'matrix' is given as a 'array of arrays' of rank size.\r\n *  That is values can be assigned as   matrix[row][column]   where 'row' is\r\n *  typically the equation, and 'column' is the term of the equation.\r\n *  That is the matrix is in the form of a 'row first array'.</p>\r\n *\r\n *  <p>However 'vectors' is a 'array of arrays' which can have any number\r\n *  of columns, with each column array the same 'rank' size as 'matrix'.</p>\r\n *\r\n *  <p>This allows for simpler handling of the results, especially is only one\r\n *  column 'vector' is all that is required to produce the desired solution.</p>\r\n *\r\n *  <p>For example, the 'vectors' can consist of simple array of\r\n *  numbers.  when only one set of simultaneous equations is to be solved from\r\n *  the given set of coefficient weighted terms.</p>\r\n *\r\n *  <p>However by specifying more 'columns' (as an 'array of vector columns',\r\n *  you can use this function to solve a set of 'separable' equations.</p>\r\n *\r\n *  <p>For example a distortion function where    <code>u = U(x,y)  v = V(x,y)</code>\r\n *  And the functions U() and V() have separate coefficients, but are being\r\n *  generated from a common x,y->u,v  data set.</p>\r\n *\r\n *  <p>You can also use the 'vectors' to generate an inverse of the given 'matrix'\r\n *  though as a 'column first array' rather than a 'row first array'. For\r\n *  details see {@link http://en.wikipedia.org/wiki/Gauss-Jordan_elimination}</p>\r\n *\r\n * @memberOf lens.util.gaussJordanElimination\r\n *\r\n * @see {@link https://imagemagick.org/api/MagickCore/matrix_8c_source.html#l00480 GaussJordanElimination()} at\r\n * ImageMagick source.\r\n */\r\nclass Solver {\r\n\r\n  /**\r\n   *\r\n   * @param {Array<number[]>} matrix Square matrix to be solved.\r\n   * @param {Array<number[]>} vectors Augment results matrix.\r\n   */\r\n  constructor(matrix, vectors) {\r\n    this.solved = false;\r\n    this.matrix = matrix.map(row => row.slice());\r\n    this.vectors = vectors.map(vector => vector.slice());\r\n  }\r\n\r\n  /**\r\n   * Solves given matrix.\r\n   *\r\n   * @returns {lens.util.gaussJordanElimination.Solver}\r\n   */\r\n  solve() {\r\n    if (this.solved) {\r\n      return this;\r\n    }\r\n\r\n    this.validate();\r\n\r\n    const matrix = this.matrix;\r\n    const vectors = this.vectors;\r\n    const rank = matrix.length;\r\n    const numVectors = vectors.length;\r\n    const cols = new Array(rank).fill(0);\r\n    const rows = new Array(rank).fill(0);\r\n    const pivots = new Array(rank).fill(0);\r\n    let col = 0;\r\n    let row = 0;\r\n\r\n    for (let i = 0; i < rank; i++) {\r\n      let max = 0;\r\n\r\n      for (let j = 0; j < rank; j++) {\r\n        if (pivots[j] !== 1) {\r\n          for (let k = 0; k < rank; k++) {\r\n            if (pivots[k] !== 0) {\r\n              if (pivots[k] > 1) {\r\n                unsolvable();\r\n              }\r\n            } else if (Math.abs(matrix[j][k]) >= max) {\r\n              max = Math.abs(matrix[j][k]);\r\n              row = j;\r\n              col = k;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      pivots[col]++;\r\n\r\n      if (row !== col) {\r\n        for (let k = 0; k < rank; k++) {\r\n          swap(matrix, row, k, col, k);\r\n        }\r\n\r\n        for (let k = 0; k < numVectors; k++) {\r\n          swap(vectors, k, row, k, col);\r\n        }\r\n      }\r\n\r\n      rows[i] = row;\r\n      cols[i] = col;\r\n\r\n      if (matrix[col][col] === 0) {\r\n        unsolvable();\r\n      }\r\n\r\n      let scale = perceptibleReciprocal(matrix[col][col]);\r\n      matrix[col][col] = 1;\r\n\r\n      for (let j = 0; j < rank; j++) {\r\n        matrix[col][j] *= scale;\r\n      }\r\n\r\n      for (let j = 0; j < numVectors; j++) {\r\n        vectors[j][col] *= scale;\r\n      }\r\n\r\n      for (let j = 0; j < rank; j++) {\r\n        if (j !== col) {\r\n          let scale = matrix[j][col];\r\n          matrix[j][col] = 0;\r\n\r\n          for (let k = 0; k < rank; k++) {\r\n            matrix[j][k] -= scale * matrix[col][k];\r\n          }\r\n\r\n          for (let k = 0; k < numVectors; k++) {\r\n            vectors[k][j] -= scale * vectors[k][col];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let j = rank - 1; j >= 0; j--) {\r\n      if (cols[j] !== rows[j]) {\r\n        for (let i = 0; i < rank; i++) {\r\n          swap(matrix, i, rows[j], i, cols[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.solved = true;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns augment matrix (results)\r\n   *\r\n   * @returns {Array.<number[]>}\r\n   */\r\n  getVectors() {\r\n    return this.vectors.map(vector => vector.slice());\r\n  }\r\n\r\n\r\n  /**\r\n   * Validates matrix and vectors.\r\n   * @protected\r\n   * @returns {lens.util.gaussJordanElimination.Solver}\r\n   */\r\n  validate() {\r\n    const rank = this.matrix.length;\r\n\r\n    this.matrix.forEach(row => {\r\n      if (row.length !== rank) {\r\n        throw new Error('Matrix must be square');\r\n      }\r\n    });\r\n\r\n    this.vectors.forEach(vector => {\r\n      if (vector.length !== rank) {\r\n        throw new Error('Vectors must be the same length as matrix rank');\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Solver;","import Solver from './solver';\r\n\r\n/**\r\n * @summary Solves system of equations using Least Squares method.\r\n * @memberOf lens.util.gaussJordanElimination\r\n * @see {@link https://imagemagick.org/api/MagickCore/matrix_8c_source.html#l00829 LeastSquaresAddTerms()} at\r\n * ImageMagick source.\r\n */\r\nclass LeastSquares extends Solver {\r\n\r\n  /**\r\n   *\r\n   * @param {number} rank The rank or size of the dimensions of the square matrix.\r\n   * Also the length of vectors, and number of terms being added.\r\n   * @param {number} numVectors Number of result vectors, and number or results being\r\n   * added.  Also represents the number of separable systems of equations\r\n   * that is being solved.\r\n   */\r\n  constructor(rank, numVectors = 1) {\r\n    const matrix = [];\r\n    const vectors = [];\r\n\r\n    for (let i = 0; i < rank; i++) {\r\n      matrix.push(new Array(rank).fill(0));\r\n    }\r\n\r\n    for (let i = 0; i < numVectors; i++) {\r\n      vectors.push(new Array(rank).fill(0));\r\n    }\r\n\r\n    super(matrix, vectors);\r\n  }\r\n\r\n  /**\r\n   * Adds one set of terms and associate results to the\r\n   * given matrix and vectors for solving using least-squares function fitting.\r\n   *\r\n   * @param {number[]} terms The pre-calculated terms (without the unknown coefficient\r\n   * weights) that forms the equation being added.\r\n   * @param {number[]} results The result(s) that should be generated from the given terms\r\n   * weighted by the yet-to-be-solved coefficients.\r\n   * @returns {lens.util.gaussJordanElimination.LeastSquares}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/matrix_8c_source.html#l00829 LeastSquaresAddTerms()} at\r\n   * ImageMagick source.\r\n   */\r\n  addTerms(terms, results) {\r\n    const rank = this.matrix.length;\r\n\r\n    for (let j = 0; j < rank; j++) {\r\n      for (let i = 0; i < rank; i++) {\r\n        this.matrix[i][j] += terms[i] * terms[j];\r\n      }\r\n\r\n      for (let i = 0; i < this.vectors.length; i++) {\r\n        this.vectors[i][j] += results[i] * terms[j];\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default LeastSquares;","/**\r\n * @summary Virtual viewport class.\r\n *\r\n * @description Represents image's virtual position at it's coordinate space.\r\n *\r\n * @memberOf lens\r\n * @see {@link https://www.imagemagick.org/Usage/basics/#page Virtual canvas offset} at ImageMagick docs.\r\n * @tutorial 02.06.virtual-viewport\r\n */\r\nclass Viewport {\r\n  /**\r\n   *\r\n   * @param {number} x1 Left edge coordinate of viewport.\r\n   * @param {number} y1 Top edge coordinate  of viewport.\r\n   * @param {number} x2 Right edge coordinate of viewport.\r\n   * @param {number} y2 Bottom edge coordinate of viewport.\r\n   */\r\n  constructor(x1, y1, x2, y2) {\r\n    /**\r\n     * Left edge coordinate of viewport.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.x1 = x1;\r\n\r\n    /**\r\n     * Top edge coordinate of viewport.\r\n     * @type {number}\r\n     */\r\n    this.y1 = y1;\r\n\r\n    /**\r\n     * Right edge coordinate of viewport.\r\n     * @type {number}\r\n     */\r\n    this.x2 = x2;\r\n\r\n    /**\r\n     * Bottom edge coordinate of viewport.\r\n     * @type {number}\r\n     */\r\n    this.y2 = y2;\r\n  }\r\n\r\n  /**\r\n   * Returns virtual viewport width -- same as image actual width.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  width() {\r\n    return this.x2 - this.x1 + 1;\r\n  }\r\n\r\n  /**\r\n   * Returns virtual viewport height -- same as image actual height.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  height() {\r\n    return this.y2 - this.y1 + 1;\r\n  }\r\n\r\n  /**\r\n   * Returns viewport area.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  area() {\r\n    return this.width() * this.height();\r\n  }\r\n\r\n  /**\r\n   * Checks if viewport contains given coords.\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {boolean}\r\n   */\r\n  contains(x, y) {\r\n    return x >= this.x1 && x <= this.x2 && y >= this.y1 && y <= this.y2;\r\n  }\r\n\r\n  /**\r\n   * Expands viewport to contain given coords.\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {lens.Viewport}\r\n   */\r\n  expand(x, y) {\r\n    this.x1 = Math.min(this.x1, x);\r\n    this.x2 = Math.max(this.x2, x);\r\n    this.y1 = Math.min(this.y1, y);\r\n    this.y2 = Math.max(this.y2, y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clones viewport into new instance.\r\n   *\r\n   * @returns {lens.Viewport}\r\n   */\r\n  clone() {\r\n    return new this.constructor(this.x1, this.y1, this.x2, this.y2);\r\n  }\r\n\r\n  /**\r\n   * Fix bounds after best fit viewport calculation.\r\n   *\r\n   * @returns {lens.Viewport}\r\n   */\r\n  fixBounds() {\r\n    this.x1 = Math.floor(this.x1 - 0.5);\r\n    this.y1 = Math.floor(this.y1 - 0.5);\r\n    this.x2 = Math.ceil(this.x2 - 0.5);\r\n    this.y2 = Math.ceil(this.y2 - 0.5);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales viewport bounds.\r\n   *\r\n   * @param {number} scale\r\n   * @returns {lens.Viewport}\r\n   */\r\n  scale(scale) {\r\n    this.x1 = Math.round(this.x1 * scale);\r\n    this.y1 = Math.round(this.y1 * scale);\r\n    this.x2 = Math.round(this.x2 * scale);\r\n    this.y2 = Math.round(this.y2 * scale);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resets viewport offset.\r\n   *\r\n   * @returns {lens.Viewport}\r\n   */\r\n  reset() {\r\n    let width = this.width(),\r\n        height = this.height();\r\n    this.x1 = 0;\r\n    this.y1 = 0;\r\n    this.x2 = this.x1 + width - 1;\r\n    this.y2 = this.y1 + height - 1;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets viewport offset\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {lens.Viewport}\r\n   */\r\n  offset(x, y) {\r\n    this.x1 += x;\r\n    this.y1 += y;\r\n    this.x2 += x;\r\n    this.y2 += y;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Viewport;","import Viewport from \"../viewport\";\r\n\r\n/**\r\n * Mixin for classes implementing {@link DistortionInterface} that can calculate best fit viewport using forward\r\n * pixel mapping of image corners.\r\n *\r\n * @memberOf lens.mixins\r\n * @mixin\r\n */\r\nconst createsBestFitViewportFromApexes = {\r\n  /**\r\n   * Returns best fit viewport for distortion, using forward mapping for image apexes (corners).\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @returns {lens.Viewport}\r\n   */\r\n  getBestFitViewport(viewport) {\r\n    const u1 = viewport.x1,\r\n      v1 = viewport.y1,\r\n      u2 = viewport.x2 + 1,\r\n      v2 = viewport.y2 + 1,\r\n      [x, y] = this.forwardMap(u1, v1),\r\n      bestFit = new Viewport(x, y, x, y);\r\n\r\n    [[u2, v1], [u2, v2], [u1, v2]].forEach(apex => bestFit.expand(...this.forwardMap(...apex)));\r\n\r\n    bestFit.fixBounds();\r\n\r\n    return bestFit;\r\n  }\r\n};\r\n\r\nexport default createsBestFitViewportFromApexes;","import LensException from './lens-exception';\r\n\r\n/**\r\n * Exception for cases when invalid number of arguments passed\r\n *\r\n * @extends lens.exception.LensException\r\n * @memberOf lens.exception\r\n */\r\nclass InvalidArgumentsLength extends LensException {\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'InvalidArgumentsLength';\r\n  }\r\n}\r\n\r\nexport default InvalidArgumentsLength;","import LeastSquares from \"../util/gauss-jordan-elimination/least-squares\";\r\nimport createsBestFitViewportFromApexes from '../mixins/creates-bestFit-viewport-from-apexes';\r\nimport InvalidArgumentsLength from '../exception/invalid-arguments-length';\r\nimport {perceptibleReciprocal} from \"../util/util\";\r\n\r\n/**\r\n * Project coordinates using projection matrix.\r\n *\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number[]} matrix Affine matrix.\r\n * @returns {Point} Mapped coords pair.\r\n */\r\nfunction map(x, y, matrix) {\r\n  return [\r\n    matrix[0] * x + matrix[1] * y + matrix[2],\r\n    matrix[3] * x + matrix[4] * y + matrix[5]\r\n  ];\r\n}\r\n\r\n/**\r\n * Affine distortion.\r\n *\r\n * @implements {DistortionInterface}\r\n * @memberOf lens.distortion\r\n * @mixes lens.mixins.createsBestFitViewportFromApexes\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#affine Affine distortion details at ImageMagick docs}\r\n * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l02443 Affine distortion at ImageMagick source}\r\n * @tutorial 03.01.affine\r\n */\r\nclass Affine {\r\n  /**\r\n   *\r\n   * @param {number[]} matrix Affine matrix.\r\n   */\r\n  constructor(matrix) {\r\n    this.matrix = matrix;\r\n    this.forwardMatrix = this.constructor.invertAffineMatrix(matrix);\r\n    this.hasPartialDerivatives = true;\r\n    this.hasConstantPartialDerivatives = true;\r\n    this.hasBestFitViewport = true;\r\n  }\r\n\r\n  /**\r\n   * Creates affine distortion using control points array.\r\n   *\r\n   * @param {number[]} controlPoints Mappings of control points [u0, v0, x0, y0, ... , un, vn, xn, yn] where\r\n   * (u*, v*) are source (x, y) point and (x*, y*) are destination (x, y) point\r\n   * @returns {lens.distortion.Affine}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00501 Generating affine distortion matrix from control points at ImageMagick source}\r\n   */\r\n  static fromControlPoints(controlPoints) {\r\n    if (controlPoints.length % 4 !== 0) {\r\n      throw new InvalidArgumentsLength(`Number of arguments must be multiple of 4 and at least 4 arguments (1 control point) expected. ${controlPoints.length} arguments given.`);\r\n    }\r\n\r\n    /*\r\n     * handle special cases of not enough arguments\r\n     */\r\n    if (controlPoints.length === 4) {\r\n      // Only 1 CP Set Given\r\n      return new Affine([\r\n        1, 0, controlPoints[0] - controlPoints[2],\r\n        0, 1, controlPoints[1] - controlPoints[3]\r\n      ]);\r\n    } else {\r\n      // 2 or more points (usally 3) given.\r\n      // Solve a least squares simultaneous equation for coefficients.\r\n      const leastSquares = new LeastSquares(3, 2);\r\n\r\n      for (let i = 0; i < controlPoints.length; i += 4) {\r\n        let [u, v, x, y] = controlPoints.slice(i, i + 4);\r\n\r\n        leastSquares.addTerms([\r\n          x, y, 1\r\n        ], [u, v]);\r\n      }\r\n\r\n      if (controlPoints.length === 8) {\r\n        /*\r\n         * Only two pairs were given, but we need 3 to solve the affine.\r\n         * Fake extra coordinates by rotating p1 around p0 by 90 degrees.\r\n         * x2 = x0 - (y1-y0)   y2 = y0 + (x1-x0)\r\n         */\r\n        leastSquares.addTerms(\r\n          [\r\n            controlPoints[2] - (controlPoints[7] - controlPoints[3]),\r\n            controlPoints[3] + (controlPoints[6] - controlPoints[2]),\r\n            1\r\n          ],\r\n          [\r\n            controlPoints[0] - controlPoints[5] + controlPoints[1],\r\n            controlPoints[1] + controlPoints[4] - controlPoints[0]\r\n          ]\r\n        );\r\n      }\r\n\r\n      const vectors = leastSquares.solve().getVectors();\r\n\r\n      return new Affine(vectors[0].concat(vectors[1]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates affine distortion using affine matrix.\r\n   *\r\n   * @param {number[]} matrix Affine projection coefficients: [sx, rx, tx, ry, sy, ty]\r\n   * @returns {lens.distortion.Affine}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00609 Generating inverted affine distortion matrix from forward affine matrix at ImageMagick source}\r\n   */\r\n  static fromForwardMatrix(matrix) {\r\n    // TODO: trap test for sx*sy-rx*ry == 0 (determinant = 0, no inverse)\r\n\r\n    return new Affine(this.invertAffineMatrix(matrix));\r\n  }\r\n\r\n  /**\r\n   * Creates inverted affine matrix from affine matrix.\r\n   *\r\n   * @param {number[]} matrix Affine matrix.\r\n   * @returns {number[]} Inverted affine matrix.\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00095 Inverting affine matrix at ImageMagick source}\r\n   */\r\n  static invertAffineMatrix(matrix) {\r\n    /* From \"Digital Image Warping\" by George Wolberg, page 50 */\r\n\r\n    const determinant = perceptibleReciprocal(matrix[0] * matrix[4] - matrix[1] * matrix[3]);\r\n\r\n    return [\r\n      determinant * matrix[4],\r\n      determinant * (-matrix[1]),\r\n      determinant * (matrix[1] * matrix[5] - matrix[2] * matrix[4]),\r\n      determinant * (-matrix[3]),\r\n      determinant * matrix[0],\r\n      determinant * (matrix[2] * matrix[3] - matrix[0] * matrix[5])\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  reverseMap(x, y) {\r\n    return map(x, y, this.matrix);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getValidity(x, y) {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPartialDerivatives(x, y) {\r\n    return [\r\n      this.matrix[0],\r\n      this.matrix[1],\r\n      this.matrix[3],\r\n      this.matrix[4]\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Maps source coords into destination coords.\r\n   *\r\n   * @param {number} x X-coordinate of source image point.\r\n   * @param {number} y Y-coordinate of source image point.\r\n   * @returns {Point} Forward mapped destination image coords.\r\n   */\r\n  forwardMap(x, y) {\r\n    return map(x, y, this.forwardMatrix);\r\n  }\r\n}\r\n\r\nObject.assign(Affine.prototype, createsBestFitViewportFromApexes);\r\n\r\nexport default Affine;","import LeastSquares from '../util/gauss-jordan-elimination/least-squares';\r\nimport createsBestFitViewportFromApexes from '../mixins/creates-bestFit-viewport-from-apexes';\r\nimport InvalidArgumentsLength from '../exception/invalid-arguments-length';\r\nimport {perceptibleReciprocal} from \"../util/util\";\r\n\r\n/**\r\n * Project coordinates using projection matrix\r\n *\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number[]} matrix Perspective matrix.\r\n * @returns {Point} Mapped coords pair.\r\n * @tutorial 03.02.perspective\r\n */\r\nfunction map(x, y, matrix) {\r\n  let p = matrix[0] * x + matrix[1] * y + matrix[2],\r\n    q = matrix[3] * x + matrix[4] * y + matrix[5],\r\n    r = matrix[6] * x + matrix[7] * y + 1;\r\n\r\n  return [p / r, q / r];\r\n}\r\n\r\n/**\r\n * @summary Perspective Distortion (a ratio of affine distortions).\r\n *\r\n * @description <pre>\r\n *\r\n *     p(x,y)    c0*x + c1*y + c2\r\n * u = ------ = ------------------\r\n *     r(x,y)    c6*x + c7*y + 1\r\n *\r\n *     q(x,y)    c3*x + c4*y + c5\r\n * v = ------ = ------------------\r\n *      r(x,y)    c6*x + c7*y + 1\r\n *\r\n * denominator = Sign of 'r', or the denominator affine, for the actual image.\r\n * This determines what part of the distorted image is 'ground'\r\n * side of the horizon, the other part is 'sky' or invalid.\r\n * Valid values are  +1.0  or  -1.0  only.\r\n * </pre>\r\n *\r\n * @implements {DistortionInterface}\r\n * @memberOf lens.distortion\r\n * @mixes lens.mixins.createsBestFitViewportFromApexes\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#perspective Perspective distortion details at ImageMagick docs}\r\n * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l02450 Perspective distortion at ImageMagick source}\r\n */\r\nclass Perspective {\r\n\r\n  /**\r\n   *\r\n   * @param {number[]} reverseMatrix Perspective projection matrix for reverse pixel mapping.\r\n   * @param {number} denominator Denominator for mapping validity calculation.\r\n   */\r\n  constructor(reverseMatrix, denominator) {\r\n    this.matrix = reverseMatrix;\r\n    this.denominator = denominator;\r\n    this.forwardMatrix = this.constructor.invertPerspectiveMatrix(reverseMatrix);\r\n    this.hasPartialDerivatives = true;\r\n    this.hasConstantPartialDerivatives = false;\r\n    this.hasBestFitViewport = true;\r\n  }\r\n\r\n  /**\r\n   * Creates perspective distortion using control points array.\r\n   *\r\n   * @param {number[]} controlPoints Mappings of control points [u0, v0, x0, y0, ... , un, vn, xn, yn] where\r\n   * (u*, v*) are source (x, y) point and (x*, y*) are destination (x, y) point.\r\n   * @returns {lens.distortion.Perspective} New instance.\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00745 Generating perspective distortion matrix from control points at ImageMagick source}\r\n   */\r\n  static fromControlPoints(controlPoints) {\r\n    if (controlPoints.length < 16 || controlPoints.length % 4 !== 0) {\r\n      throw new InvalidArgumentsLength(`Number of arguments must be multiple of 4 and at least 16 arguments (4 control points) expected. ${controlPoints.length} arguments given.`);\r\n    }\r\n\r\n    const leastSquares = new LeastSquares(8, 1);\r\n\r\n    for (let i = 0; i < controlPoints.length; i += 4) {\r\n      let [u, v, x, y] = controlPoints.slice(i, i + 4);\r\n\r\n      leastSquares.addTerms([\r\n        x, y, 1,\r\n        0, 0, 0,\r\n        -x * u, -y * u\r\n      ], [u])\r\n        .addTerms([\r\n          0, 0, 0,\r\n          x, y, 1,\r\n          -x * v, -y * v\r\n        ], [v]);\r\n    }\r\n\r\n    const matrix = leastSquares.solve().getVectors()[0];\r\n\r\n    /*\r\n     * Calculate denominator! The ground-sky determination.\r\n     * What is sign of the 'ground' in r() denominator affine function?\r\n     * Just use any valid image coordinate (first control point) in\r\n     * destination for determination of what part of view is 'ground'.\r\n     */\r\n    const denominator = matrix[6] * controlPoints[2] + matrix[7] * controlPoints[3] + 1 < 0 ? -1 : 1;\r\n\r\n    return new Perspective(matrix, denominator);\r\n  }\r\n\r\n  /**\r\n   * Creates perspective distortion using perspective matrix.\r\n   *\r\n   * @param {number[]} matrix Perspective matrix.\r\n   * @returns {lens.distortion.Perspective}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00853 Generating inverted perspective distortion matrix from forward perspective matrix at ImageMagick docs}\r\n   */\r\n  static fromForwardMatrix(matrix) {\r\n    // TODO: trap test  c0*c4-c3*c1 == 0  (determinant = 0, no inverse)\r\n    const inverse = this.invertPerspectiveMatrix(matrix);\r\n\r\n    /*\r\n     * Calculate denominator! The ground-sky determination.\r\n     * What is sign of the 'ground' in r() denominator affine function?\r\n     * Just use any valid image coordinate in destination for determination.\r\n     * For a forward mapped perspective the images 0,0 coord will map to\r\n     * c2,c5 in the distorted image, so set the sign of denominator of that.\r\n     */\r\n    const denominator = inverse[6] * matrix[2] + inverse[7] * matrix[5] + 1 < 0 ? -1 : 1;\r\n    return new Perspective(inverse, denominator);\r\n  }\r\n\r\n  /**\r\n   * Creates inverted perspective matrix from perspective matrix.\r\n   *\r\n   * @param {number[]} matrix Perspective matrix.\r\n   * @returns {number[]} Inverted perspective matrix.\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00109 Inverting perspective matrix at ImageMagick source}\r\n   */\r\n  static invertPerspectiveMatrix(matrix) {\r\n    const determinant = perceptibleReciprocal(matrix[0] * matrix[4] - matrix[3] * matrix[1]);\r\n\r\n    return [\r\n      determinant * (matrix[4] - matrix[7] * matrix[5]),\r\n      determinant * (matrix[7] * matrix[2] - matrix[1]),\r\n      determinant * (matrix[1] * matrix[5] - matrix[4] * matrix[2]),\r\n      determinant * (matrix[6] * matrix[5] - matrix[3]),\r\n      determinant * (matrix[0] - matrix[6] * matrix[2]),\r\n      determinant * (matrix[3] * matrix[2] - matrix[0] * matrix[5]),\r\n      determinant * (matrix[3] * matrix[7] - matrix[6] * matrix[4]),\r\n      determinant * (matrix[6] * matrix[1] - matrix[0] * matrix[7])\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  reverseMap(x, y) {\r\n    return map(x, y, this.matrix);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getValidity(x, y, scaling) {\r\n    const r = this.matrix[6] * x + this.matrix[7] * y + 1;\r\n    let validity = r * this.denominator < 0 ? 0 : 1;\r\n    const absR = Math.abs(r) * 2;\r\n    const absC6 = Math.abs(this.matrix[6]);\r\n    const absC7 = Math.abs(this.matrix[7]);\r\n\r\n    if (absC6 > absC7) {\r\n      if (absR < absC6) {\r\n        validity = 0.5 - this.denominator * r / (this.matrix[6] * scaling);\r\n      }\r\n    } else if (absR < absC7) {\r\n      validity = 0.5 - this.denominator * r / (this.matrix[7] * scaling);\r\n    }\r\n\r\n    return validity;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPartialDerivatives(x, y) {\r\n    const p = this.matrix[0] * x + this.matrix[1] * y + this.matrix[2],\r\n      q = this.matrix[3] * x + this.matrix[4] * y + this.matrix[5],\r\n      r = this.matrix[6] * x + this.matrix[7] * y + 1,\r\n      scale = Math.pow(1 / r, 2);\r\n\r\n    return [\r\n      (r * this.matrix[0] - p * this.matrix[6]) * scale, // dUx\r\n      (r * this.matrix[1] - p * this.matrix[7]) * scale, // dUy\r\n      (r * this.matrix[3] - q * this.matrix[6]) * scale, // dVx\r\n      (r * this.matrix[4] - q * this.matrix[7]) * scale //dVy\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Maps source coords into destination coords.\r\n   *\r\n   * @param {number} u X-coordinate of source image point.\r\n   * @param {number} v Y-coordinate of source image point.\r\n   * @returns {Point} Forward mapped destination image coords.\r\n   */\r\n  forwardMap(u, v) {\r\n    return map(u, v, this.forwardMatrix);\r\n  }\r\n}\r\n\r\nObject.assign(Perspective.prototype, createsBestFitViewportFromApexes);\r\n\r\nexport default Perspective;","import LensException from './lens-exception';\r\n\r\n/**\r\n * Invalid Argument Exception.\r\n *\r\n * @memberOf lens.exception\r\n * @extends lens.exception.LensException\r\n */\r\nclass InvalidArgument extends LensException {\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'InvalidArgument';\r\n  }\r\n}\r\n\r\nexport default InvalidArgument;","import {EPSILON, M_PI2, M_2PI} from \"../constants\";\r\nimport {InvalidArgument} from \"../exception\";\r\nimport {deg2rad} from \"../util\";\r\nimport Viewport from '../viewport';\r\n\r\n/**\r\n * @summary Arc distortion.\r\n *\r\n * @description Note the coefficients use a center angle, so asymptotic join is\r\n * furthest from both sides of the source image. This also means that\r\n * for arc angles greater than 360 the sides of the image will be\r\n * trimmed equally.\r\n *\r\n * @memberOf lens.distortion\r\n * @implements DistortionInterface\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#arc Arc distortion details} at ImageMagick docs.\r\n * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l02561 Arc distortion} at ImageMagick\r\n * source.\r\n * @tutorial 03.03.arc\r\n */\r\nclass Arc {\r\n  /**\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @param {number} c0 Angle for center of source image.\r\n   * @param {number} c1 Angle scale for mapping to source image.\r\n   * @param {number} c2 Radius for top of source image.\r\n   * @param {number} c3 Radius scale for mapping source image.\r\n   * @param {number} c4 Center line of arc within source image.\r\n   */\r\n  constructor(viewport, c0, c1, c2, c3, c4) {\r\n    this.viewport = viewport;\r\n    this.c0 = c0;\r\n    this.c1 = c1;\r\n    this.c2 = c2;\r\n    this.c3 = c3;\r\n    this.c4 = c4;\r\n\r\n    /*\r\n     * Convert the angle_to_width and radius_to_height\r\n     * to appropriate scaling factors, to allow faster processing\r\n     * in the mapping function.\r\n     */\r\n    this.angleToWidth = M_2PI * this.viewport.width() / this.c1;\r\n    this.radiusToHeight = this.viewport.height() / this.c3;\r\n\r\n    this.hasPartialDerivatives = true;\r\n    this.hasConstantPartialDerivatives = false;\r\n    this.hasBestFitViewport = true;\r\n    this.forceBestFit = true;\r\n  }\r\n\r\n  /**\r\n   * @summary Creates arc distortion class from arguments.\r\n   *\r\n   * @description Arguments:  [angle, rotation, outer_radius, inner_radius]\r\n   * All but first argument are optional.\r\n   *\r\n   * By default, if the radii arguments are nor provided the image radius\r\n   * is calculated so the horizontal center-line is fits the given arc\r\n   * without scaling.\r\n   *\r\n   * The output image size is ALWAYS adjusted to contain the whole image,\r\n   * and an offset is given to position image relative to the 0,0 point of\r\n   * the origin, allowing users to use relative positioning onto larger\r\n   * background.\r\n   *\r\n   * The arguments are converted to distortion coefficients.\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @param {number[]} args Arguments:\r\n   * * 0: **angle** - The angle over which to arc the image side-to-side.\r\n   * * 1: **rotation** - Angle to rotate image from vertical center.\r\n   * * 2: **outer_radius** - Set top edge of source image at this radius.\r\n   * * 3: **inner_radius** - Set bottom edge to this radius (radial scaling).\r\n   * @returns {lens.distortion.Arc}\r\n   * @throws {lens.exception.InvalidArgument} Thrown when first (angle) or third (outer radius) arguments are too small\r\n   *\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l01095 Generating coefficients} for arc\r\n   * distortion at ImageMagick source.\r\n   */\r\n  static fromArguments(viewport, args) {\r\n    if (args.length >= 1 && args[0] < EPSILON) {\r\n      throw new InvalidArgument('Angle too small');\r\n    }\r\n\r\n    if (args.length >= 3 && args[2] < EPSILON) {\r\n      throw new InvalidArgument('Outer radius too small');\r\n    }\r\n\r\n    let c0, c1, c2, c3, c4;\r\n\r\n    c0 = -M_PI2; // -90, place at top!\r\n\r\n    if (args.length >= 1) {\r\n      c1 = deg2rad(args[0]);\r\n    } else {\r\n      c1 = M_PI2; // zero arguments - center is at top\r\n    }\r\n\r\n    if (args.length >= 2) {\r\n      c0 += deg2rad(args[1]);\r\n    }\r\n\r\n    c0 /= M_2PI; // normalize radians\r\n    c0 -= Math.round(c0);\r\n    c0 *= M_2PI; // de-normalize back to radians\r\n\r\n    c3 = viewport.height() - 1;\r\n    c2 = viewport.width() / c1 + c3 / 2;\r\n\r\n    if (args.length >= 3) {\r\n      if (args.length >= 4) {\r\n        c3 = args[2] - args[3];\r\n      } else {\r\n        c3 *= args[2] / c2;\r\n      }\r\n\r\n      c2 = args[2];\r\n    }\r\n\r\n    c4 = (viewport.width() - 1) / 2;\r\n\r\n    return new Arc(viewport, c0, c1, c2, c3, c4);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  reverseMap(x, y) {\r\n    let [u, v] = this.getUV(x, y);\r\n\r\n    // now scale the angle and radius for source image lookup point\r\n    u = u * this.angleToWidth + this.c4 + this.viewport.x1 + 0.5;\r\n    v = (this.c2 - v) * this.radiusToHeight + this.viewport.y1;\r\n\r\n    //console.log(u, v, x, y);\r\n\r\n    return [u, v];\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getValidity(x, y) {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPartialDerivatives(x, y) {\r\n    let [u, v] = this.getUV(x, y);\r\n\r\n    /*\r\n     * Arc Distortion Partial Scaling Vectors\r\n     * Are derived by mapping the perpendicular unit vectors\r\n     * dR  and  dA*R*2PI  rather than trying to map dx and dy\r\n     * The results is a very simple orthogonal aligned ellipse.\r\n     */\r\n    if (v > EPSILON) {\r\n      return [this.angleToWidth / (M_2PI * v), 0, 0, this.radiusToHeight];\r\n    } else {\r\n      return [this.viewport.width() * 2, 0, 0, this.radiusToHeight];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns calculated best fit viewport for image.\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @returns {lens.Viewport}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l01834 Generating best fit viewport}\r\n   * for arc distortion at ImageMagick source.\r\n   */\r\n  getBestFitViewport(viewport) {\r\n    // Forward Map Corners\r\n    let a = this.c0 - this.c1 / 2,\r\n      ca = Math.cos(a),\r\n      sa = Math.sin(a),\r\n      x = this.c2 * ca,\r\n      y = this.c2 * sa,\r\n      vp = new Viewport(x, y, x, y);\r\n\r\n    x = (this.c2 - this.c3) * ca;\r\n    y = (this.c2 - this.c3) * sa;\r\n    vp.expand(x, y);\r\n\r\n    a = this.c0 + this.c1 / 2;\r\n    ca = Math.cos(a);\r\n    sa = Math.sin(a);\r\n    x = this.c2 * ca;\r\n    y = this.c2 * sa;\r\n    vp.expand(x, y);\r\n\r\n    x = (this.c2 - this.c3) * ca;\r\n    y = (this.c2 - this.c3) * sa;\r\n    vp.expand(x, y);\r\n\r\n    // Orthogonal points along top of arc\r\n    for (\r\n      a = Math.ceil((this.c0 - this.c1 / 2) / M_PI2) * M_PI2;\r\n      a < this.c0 + this.c1 / 2;\r\n      a += M_PI2\r\n    ) {\r\n      ca = Math.cos(a);\r\n      sa = Math.sin(a);\r\n      x = this.c2 * ca;\r\n      y = this.c2 * sa;\r\n      vp.expand(x, y);\r\n    }\r\n\r\n    vp.fixBounds();\r\n\r\n    return vp;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {Point}\r\n   */\r\n  getUV(x, y) {\r\n    let u, v;\r\n\r\n    // what is the angle and radius in the destination image\r\n    u = (Math.atan2(y, x) - this.c0) / M_2PI;\r\n    u -= Math.round(u);\r\n    v = Math.hypot(x, y);\r\n\r\n    return [u, v];\r\n  }\r\n}\r\n\r\nexport default Arc;","import vpxMethods from '../vpx';\r\n\r\n/**\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Point}\r\n */\r\nfunction getEdgeCoords(x, y, width, height) {\r\n  return [\r\n    Math.max(0, Math.min(width - 1, x)),\r\n    Math.max(0, Math.min(height - 1, y))\r\n  ];\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Point}\r\n */\r\nfunction getTileCoords(x, y, width, height) {\r\n  let rx = x % width,\r\n    ry = y % height;\r\n\r\n  return [\r\n    rx < 0 ? width + rx : rx,\r\n    ry < 0 ? height + ry : ry\r\n  ];\r\n}\r\n\r\n/**\r\n * Adds virtual pixel behavior to classes that implement ImageInterface.\r\n *\r\n * @mixin\r\n * @memberOf lens.mixins\r\n * @tutorial 02.05.virtual-pixels-and-matte\r\n */\r\nconst virtualPixelTrait = {\r\n  /**\r\n   * Returns virtual pixel color.\r\n   *\r\n   * @param {number} x Image X-coordinate OUTSIDE of image bounds.\r\n   * @param {number} y Image Y-coordinate OUTSIDE of image bounds.\r\n   * @param {lens.vpx} method Virtual pixel method.\r\n   * @returns {Color}\r\n   */\r\n  getVirtualPixelColor(x, y, method) {\r\n    switch (method) {\r\n      case vpxMethods.BACKGROUND:\r\n        return this.backgroundColor.slice();\r\n\r\n      case vpxMethods.EDGE:\r\n        return this.getImagePixelColor(...getEdgeCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.MIRROR:\r\n        let [tx, ty] = getTileCoords(x, y, this.width * 2, this.height * 2);\r\n\r\n        if (tx > this.width - 1) {\r\n          tx = this.width - (tx - this.width) - 1;\r\n        }\r\n\r\n        if (ty > this.height - 1) {\r\n          ty = this.height - (ty - this.height) - 1;\r\n        }\r\n\r\n        return this.getImagePixelColor(tx, ty);\r\n\r\n      case vpxMethods.TILE:\r\n        return this.getImagePixelColor(...getTileCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.TRANSPARENT:\r\n      default:\r\n        return [0, 0, 0, 0];\r\n\r\n      case vpxMethods.BLACK:\r\n        return [0, 0, 0, this.quantumRange];\r\n\r\n      case vpxMethods.WHITE:\r\n        return new Array(4).fill(this.quantumRange);\r\n\r\n      case vpxMethods.GRAY:\r\n        return new Array(3).fill(Math.round(this.quantumRange / 2)).concat([this.quantumRange]);\r\n\r\n      case vpxMethods.HORIZONTAL_TILE:\r\n      case vpxMethods.HORIZONTAL_TILE_EDGE:\r\n        if (y < 0 || y >= this.height) {\r\n          return method === vpxMethods.HORIZONTAL_TILE ? this.backgroundColor.slice()\r\n            : this.getImagePixelColor(...getEdgeCoords(x, y, this.width, this.height));\r\n        }\r\n\r\n        return this.getImagePixelColor(...getTileCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.VERTICAL_TILE:\r\n      case vpxMethods.VERTICAL_TILE_EDGE:\r\n        if (x < 0 || x >= this.width) {\r\n          return method === vpxMethods.VERTICAL_TILE ? this.backgroundColor.slice()\r\n            : this.getImagePixelColor(...getEdgeCoords(x, y, this.width, this.height));\r\n        }\r\n\r\n        return this.getImagePixelColor(...getTileCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.RANDOM:\r\n        return this.getImagePixelColor(\r\n          Math.floor(Math.random() * this.width),\r\n          Math.floor(Math.random() * this.height)\r\n        );\r\n    }\r\n  }\r\n};\r\n\r\nexport default virtualPixelTrait;","import methods from '../interpolation';\r\n\r\n/**\r\n * Adds color interpolation functionality for classes that implement {@link ImageInterface}\r\n *\r\n * @mixin\r\n * @memberOf lens.mixins\r\n */\r\nconst interpolationTrait = {\r\n  /**\r\n   * Returns interpolated pixel color.\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {lens.interpolation} [interpolationMethod=this.interpolationMethod]\r\n   * @returns {Color}\r\n   */\r\n  getInterpolatedPixelColor(x, y, interpolationMethod = this.interpolationMethod) {\r\n    switch (interpolationMethod) {\r\n      case methods.AVERAGE:\r\n        return this.interpolateAverage(x, y, 2);\r\n      case methods.AVERAGE_9:\r\n        return this.interpolateAverage(x, y, 3);\r\n      case methods.AVERAGE_16:\r\n        return this.interpolateAverage(x, y, 4);\r\n      case methods.BACKGROUND:\r\n        return this.backgroundColor.slice();\r\n      case methods.INTEGER:\r\n      default:\r\n        return this.getPixelColor(Math.floor(x), Math.floor(y));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns interpolated color by average of neighbors.\r\n   *\r\n   * @private\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} count\r\n   * @returns {Color}\r\n   */\r\n  interpolateAverage(x, y, count = 2) {\r\n    let startX, startY;\r\n\r\n    switch (count) {\r\n      case 2:\r\n        startX = Math.floor(x);\r\n        startY = Math.floor(y);\r\n        break;\r\n\r\n      case 3:\r\n        startX = Math.floor(x + 0.5) - 1;\r\n        startY = Math.floor(y + 0.5) - 1;\r\n        break;\r\n      case 4:\r\n        startX = Math.floor(x) - 1;\r\n        startY = Math.floor(y) - 1;\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Param 'count' must be integer between 2 and 4.\");\r\n    }\r\n\r\n    const endX = startX + count;\r\n    const endY = startY + count;\r\n    let color = [0, 0, 0, 0];\r\n\r\n    for (let Y = startY; Y < endY; Y++) {\r\n      for (let X = startX; X < endX; X++) {\r\n        this.getPixelColor(x, y).forEach((channel, i) => color[i] += channel);\r\n      }\r\n    }\r\n\r\n    const gamma = 1 / (count * count);\r\n\r\n    return color.map(channel => Math.round(channel * gamma));\r\n  }\r\n};\r\n\r\nexport default interpolationTrait;","import Viewport from '../viewport';\r\nimport vpx from '../vpx';\r\nimport virtualPixelTrait from '../mixins/virtual-pixel-trait';\r\nimport interpolationTrait from '../mixins/interpolation-trait';\r\nimport interpolation from '../interpolation';\r\n\r\nfunction notImplemented(method) {\r\n  throw new Error(`${method}() is abstract method and must be implemented by child class`);\r\n}\r\n\r\n/**\r\n * Abstract image class for ImageInterface implementation.\r\n *\r\n * @implements {ImageInterface}\r\n * @memberOf lens.image\r\n * @abstract\r\n * @mixes lens.mixins.interpolationTrait\r\n * @mixes lens.mixins.virtualPixelTrait\r\n */\r\nclass AbstractImage {\r\n\r\n  /**\r\n   * @param {number} width Image width\r\n   * @param {number} height Image height\r\n   */\r\n  constructor(width, height) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.viewport = new Viewport(0, 0, this.width - 1, this.height - 1);\r\n    this.backgroundColor = [0, 0, 0, 0]; // Transparent;\r\n    this.virtualPixelMethod = vpx.TRANSPARENT;\r\n    this.quantumRange = 255;\r\n    this.interpolationMethod = interpolation.INTEGER;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPixelColor(x, y) {\r\n    x = Math.floor(x - this.viewport.x1);\r\n    y = Math.floor(y - this.viewport.y1);\r\n\r\n    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\r\n      return this.getImagePixelColor(x, y);\r\n    }\r\n\r\n    return this.getVirtualPixelColor(x, y, this.virtualPixelMethod);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setPixelColor(x, y, color) {\r\n    x = Math.floor(x - this.viewport.x1);\r\n    y = Math.floor(y - this.viewport.y1);\r\n\r\n    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\r\n      this.setImagePixelColor(x, y, color);\r\n\r\n      return this;\r\n    }\r\n\r\n    throw new Error(`Given coords (${x}, ${y}) is out of image bounds`);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getBlank(viewport) {\r\n    const blank = this.prepareBlank(viewport.width(), viewport.height());\r\n\r\n    if (blank instanceof Promise) {\r\n      return blank.then(blank => {\r\n        blank.viewport  = viewport;\r\n        return blank;\r\n      });\r\n    }\r\n\r\n    blank.viewport = viewport;\r\n    return blank;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  scale(scale) {\r\n    const viewport = this.viewport.clone();\r\n    viewport.scale(scale);\r\n    const resized = this.resize(viewport.width(), viewport.height());\r\n\r\n    if (resized instanceof Promise) {\r\n      return resized.then(() => {\r\n        resized.viewport = viewport;\r\n        return resized;\r\n      });\r\n    }\r\n\r\n    resized.viewport = viewport;\r\n    return resized;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  sync() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns pixel color at given image coords. Image coords MUST be: x  [0; width - 1], y  [0; height - 1].\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {Color}\r\n   */\r\n  getImagePixelColor(x, y) {\r\n    notImplemented('getImagePixelColor');\r\n  }\r\n\r\n  /**\r\n   * Sets pixel color at given image coordinates.\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {Color} color\r\n   */\r\n  setImagePixelColor(x, y, color) {\r\n    notImplemented('setImagePixelColor');\r\n  }\r\n\r\n  /**\r\n   * Prepares blank image for {@link ImageInterface#getBlank} method.\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @returns {ImageInterface}\r\n   */\r\n  prepareBlank(width, height) {\r\n    notImplemented('prepareBlank');\r\n  }\r\n\r\n  /**\r\n   * Returns average color of whole image.\r\n   *\r\n   * @abstract\r\n   * @returns {Color}\r\n   */\r\n  getAverageColor() {\r\n    notImplemented('getAverageColor');\r\n  }\r\n\r\n  /**\r\n   * Returns resized instance of self.\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @returns {ImageInterface|Promise<ImageInterface>}\r\n   */\r\n  resize(width, height) {\r\n    notImplemented('resize');\r\n  }\r\n}\r\n\r\nObject.assign(AbstractImage.prototype, virtualPixelTrait);\r\nObject.assign(AbstractImage.prototype, interpolationTrait);\r\n\r\nexport default AbstractImage;","import AbstractImage from './abstract-image';\r\n\r\n/**\r\n * ImageInterface implementation for distortion using HTML5 Canvas objects.\r\n * Distortion result will contain new Canvas object in {@link lens.image.Canvas#canvas} property.\r\n *\r\n * @implements {ImageInterface}\r\n * @memberOf lens.image\r\n * @extends lens.image.AbstractImage\r\n */\r\nclass Canvas extends AbstractImage {\r\n\r\n  /**\r\n   *\r\n   * @param {HTMLCanvasElement} canvas\r\n   */\r\n  constructor(canvas) {\r\n    super(canvas.width, canvas.height);\r\n    this.canvas     = canvas;\r\n    this.imageData  = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\r\n    this.data       = this.imageData.data;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getImagePixelColor(x, y) {\r\n    const offset = (y * this.width + x) * 4;\r\n\r\n    return Array.prototype.slice.call(\r\n      this.data,\r\n      offset,\r\n      offset + 4\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setImagePixelColor(x, y, color) {\r\n    const offset = (y * this.width + x) * 4;\r\n\r\n    color.forEach((channel, i) => this.data[offset + i] = channel);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  prepareBlank(width, height) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    return new this.constructor(canvas);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  sync() {\r\n    this.canvas.getContext('2d').putImageData(this.imageData, 0, 0);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getAverageColor() {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    canvas.getContext('2d').drawImage(this.canvas, 0, 0, this.width, this.height, 0, 0, 1, 1);\r\n    return Array.prototype.slice.call(\r\n      canvas.getContext('2d').getImageData(0, 0, 1, 1).data\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  resize(width, height) {\r\n    const dst = document.createElement('canvas');\r\n    dst.width = width;\r\n    dst.height = height;\r\n    dst.getContext('2d').drawImage(this.canvas, 0, 0, this.width, this.height, 0, 0, width, height);\r\n    return new this.constructor(dst);\r\n  }\r\n}\r\n\r\nexport default Canvas;","import Canvas from './canvas';\r\n\r\n/**\r\n * Wrapper for {@link lens.image.Canvas} for direct distortion of DOM Image objects.\r\n * Distortion result will contain new DOM Image object in {@link lens.image.DomImage#image} property.\r\n *\r\n * @implements {ImageInterface}\r\n * @memberOf lens.image\r\n * @extends lens.image.Canvas\r\n */\r\nclass DomImage extends Canvas {\r\n  /**\r\n   *\r\n   * @param {external:Image|HTMLImageElement} image DOM Image object\r\n   */\r\n  constructor(image) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    canvas.getContext('2d').drawImage(image, 0, 0);\r\n    super(canvas);\r\n\r\n    this.image = image;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  prepareBlank(width, height) {\r\n    return new this.constructor(new Image(width, height));\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  sync() {\r\n    super.sync();\r\n\r\n    return new Promise(resolve => {\r\n      this.image.onload = () => resolve(this);\r\n\r\n      this.image.src = this.canvas.toDataURL();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  resize(width, height) {\r\n    return this.sync().then(() => {\r\n      return new Promise(resolve => {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        canvas.getContext('2d').drawImage(this.image, 0, 0, this.width, this.height, 0, 0, width, height);\r\n\r\n        const image = new Image(width, height);\r\n\r\n        image.onload = () => {\r\n          const resized = new this.constructor(image);\r\n          resolve(resized);\r\n        };\r\n\r\n        image.src = canvas.toDataURL();\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nexport default DomImage;","import Affine from './distortion/affine';\r\nimport Arc from './distortion/arc';\r\nimport Perspective from './distortion/perspective';\r\n\r\n/**\r\n * @summary Resolves distortion class instance using distortion arguments and optionally image.\r\n *\r\n * @callback lens~DistortionResolver\r\n * @param {number[]} args\r\n * @param {ImageInterface} [image]\r\n * @returns {DistortionInterface}\r\n */\r\n\r\n/**\r\n * Make Affine distortion using control points.\r\n *\r\n * @private\r\n * @param {number[]} args\r\n * @returns {lens.distortion.Affine}\r\n */\r\nfunction affineByControlPoints(args) {\r\n  return Affine.fromControlPoints(args);\r\n}\r\n\r\n/**\r\n * Make Affine distortion using affine matrix. Arguments order is as described for compatibility with ImageMagick\r\n * arguments.\r\n *\r\n * @private\r\n * @param sx\r\n * @param ry\r\n * @param rx\r\n * @param sy\r\n * @param tx\r\n * @param ty\r\n * @returns {lens.distortion.Affine}\r\n */\r\nfunction affineByMatrix ([sx, ry, rx, sy, tx, ty]) {\r\n  // Change arguments order.\r\n  return Affine.fromForwardMatrix([sx, rx, tx, ry, sy, ty]);\r\n}\r\n\r\n/**\r\n * Make perspective distortion using control points.\r\n * If number of control point sets is less than 4 (< 16 arguments), this will fallback to Affine distortion.\r\n *\r\n * @private\r\n * @param {number[]} args\r\n * @returns {lens.distortion.Perspective|lens.distortion.Affine}\r\n */\r\nfunction perspectiveByControlPoints(args) {\r\n  if (args.length < 16) {\r\n    console.warn('Perspective distortion requires at least 4 controls points mapping (u, v) -> (x, y). Affine distortion will be used.');\r\n    return Affine.fromControlPoints(args);\r\n  }\r\n\r\n  return Perspective.fromControlPoints(args);\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number[]} args\r\n * @returns {lens.distortion.Perspective}\r\n */\r\nfunction perspectiveByMatrix(args) {\r\n  return Perspective.fromForwardMatrix(args);\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number[]} args\r\n * @param {ImageInterface} image\r\n * @returns {lens.distortion.Arc}\r\n */\r\nfunction arcByArguments(args, image) {\r\n  return Arc.fromArguments(image.viewport, args);\r\n}\r\n\r\n/**\r\n * Distortion types.\r\n *\r\n * @enum {lens~distortionResolver}\r\n * @memberOf lens\r\n */\r\nconst distorts = {\r\n  /**\r\n   * Affine distortion using control points. Arguments are sets of control points mappings:\r\n   * [u0, v0, x0, y0, ..., uN, vN, xN, yN], where u*, v* are source image coords, x*, y* are\r\n   * destination image coords.\r\n   */\r\n  AFFINE: affineByControlPoints,\r\n  /**\r\n   * Affine distortion using forward affine matrix.\r\n   * Arguments are affine matrix coefficients: [sx, ry, rx, sy, tx, ty]\r\n   */\r\n  AFFINE_PROJECTION: affineByMatrix,\r\n  /**\r\n   * Perspective distortion using control points. Arguments are sets of control points mappings:\r\n   * [u0, v0, x0, y0, ..., uN, vN, xN, yN], where u*, v* are source image coords, x*, y* are\r\n   * destination image coords.\r\n   * If number of control point sets is less than 4 (< 16 arguments), this will fallback to Affine distortion\r\n   * with warning message in console.\r\n   */\r\n  PERSPECTIVE: perspectiveByControlPoints,\r\n  /**\r\n   * Perspective distortion using forward perspective matrix. Arguments are perspective matrix coefficients:\r\n   * [sx, ry, tx, rx, sy, ty, px, py].\r\n   */\r\n  PERSPECTIVE_PROJECTION: perspectiveByMatrix,\r\n\r\n  /**\r\n   * Arc distortion. Arguments are: [arcAngle, rotation, outerRadius, innerRadius]. All arguments except arcAngle\r\n   * are optional. See {@link lens.distortion.Arc.fromArguments}\r\n   */\r\n  ARC: arcByArguments\r\n};\r\n\r\n/**\r\n * Register custom distortion resolver.\r\n *\r\n * @memberOf lens\r\n * @param {string} name\r\n * @param {lens~distortionResolver} resolver\r\n */\r\nfunction registerDistortionResolver(name, resolver) {\r\n  distorts[name]  = resolver;\r\n}\r\n\r\n/**\r\n * Unregister distortion resolver.\r\n *\r\n * @memberOf lens\r\n * @param {string} name\r\n */\r\nfunction unregisterDistortionResolver(name) {\r\n  delete distorts[name];\r\n}\r\n\r\nexport {registerDistortionResolver, unregisterDistortionResolver};\r\n\r\nexport default distorts;","/**\r\n * @namespace lens\r\n */\r\n\r\n/**\r\n * Library version.\r\n *\r\n * @readonly\r\n * @memberOf lens\r\n * @type {string}\r\n */\r\nconst VERSION = '0.1.0';\r\n\r\nexport {default as distort} from './distort';\r\n\r\nexport {VERSION};\r\n\r\nimport * as distorter from './distorter';\r\nexport {distorter};\r\n\r\nimport * as distortion from './distortion';\r\nexport {distortion};\r\n\r\nimport * as exception from './exception';\r\nexport {exception};\r\n\r\nimport * as filter from './filter';\r\nexport {filter};\r\n\r\nexport {default as filterPresets} from './filter-presets';\r\n\r\nimport * as image from './image';\r\nexport {image};\r\n\r\nimport * as mixins from './mixins';\r\nexport {mixins};\r\n\r\nimport * as resampler from './resampler';\r\nexport {resampler};\r\n\r\nimport * as util from './util';\r\nexport {util};\r\n\r\nimport interpolation from './interpolation';\r\nexport {interpolation};\r\n\r\nimport vpx from './vpx';\r\nexport {vpx};\r\n\r\nimport Viewport from './viewport';\r\nexport {Viewport};\r\n\r\nimport distorts from './distorts';\r\nexport {distorts};\r\n\r\nexport {registerDistortionResolver, unregisterDistortionResolver} from './distorts';\r\n\r\nexport {\r\n  EPSILON,\r\n  MAXIMUM_VALUE,\r\n  M_PI2,\r\n  M_2PI\r\n} from './constants';"],"sourceRoot":""}