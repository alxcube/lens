{"version":3,"sources":["webpack://lens/webpack/universalModuleDefinition","webpack://lens/webpack/bootstrap","webpack://lens/./lib/distorter/reverse-pixel-mapping.js","webpack://lens/./lib/distorter/distorter.js","webpack://lens/./lib/exception/lens-exception.js","webpack://lens/./lib/exception/unsolvable-matrix.js","webpack://lens/./lib/constants.js","webpack://lens/./lib/util/util.js","webpack://lens/./lib/util/gauss-jordan-elimination/solver.js","webpack://lens/./lib/util/gauss-jordan-elimination/least-squares.js","webpack://lens/./lib/viewport.js","webpack://lens/./lib/mixins/creates-best-fit-viewport-from-apexes.js","webpack://lens/./lib/exception/invalid-arguments-length.js","webpack://lens/./lib/distortion/affine.js","webpack://lens/./lib/exception/invalid-argument.js","webpack://lens/./lib/distortion/arc.js","webpack://lens/./lib/distortion/perspective.js","webpack://lens/./lib/distortion/distortion.js","webpack://lens/./lib/exception/exception.js","webpack://lens/./lib/filter/filter.js","webpack://lens/./lib/filter/filter-functions.js","webpack://lens/./lib/filter/filter-namespace.js","webpack://lens/./lib/vpx.js","webpack://lens/./lib/mixins/virtual-pixel-trait.js","webpack://lens/./lib/interpolation.js","webpack://lens/./lib/mixins/interpolation-trait.js","webpack://lens/./lib/image/abstract-image.js","webpack://lens/./lib/image/canvas.js","webpack://lens/./lib/image/dom-image.js","webpack://lens/./lib/image/image.js","webpack://lens/./lib/mixins/mixins.js","webpack://lens/./lib/resampler/e-w-a.js","webpack://lens/./lib/resampler/point.js","webpack://lens/./lib/resampler/resampler.js","webpack://lens/./lib/util/util-namespace.js","webpack://lens/./lib/util/gauss-jordan-elimination/gauss-jordan-elimination.js","webpack://lens/./lib/filter-presets.js","webpack://lens/./lib/distort.js","webpack://lens/./lib/distorts.js","webpack://lens/./lib/lens.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ReversePixelMapping","image","distortion","resampler","mapper","bestFit","viewport","async","outputScaling","setImage","setMapper","prepareViewport","x1","Math","floor","y1","x2","y2","canvas","getBlank","scaling","Promise","then","performDistortionAsync","performDistortion","y","x","setPixelColor","getResampledColor","args","resolve","setTimeout","clone","hasBestFitViewport","getBestFitViewport","scale","distorter","LensException","message","Error","captureStackTrace","constructor","stack","UnsolvableMatrix","MAXIMUM_VALUE","M_PI2","PI","M_2PI","perceptibleReciprocal","sign","blendColors","color1","weight1","color2","weight2","map","channel","round","rad2deg","radians","deg2rad","degrees","swap","array","row1","col1","row2","col2","unsolvable","Solver","matrix","vectors","solved","row","slice","vector","validate","rank","length","numVectors","cols","Array","fill","rows","pivots","col","max","j","k","abs","forEach","LeastSquares","push","terms","results","Viewport","width","height","min","ceil","createsBestFitViewportFromApexes","u1","v1","u2","v2","forwardMap","apex","expand","fixBounds","InvalidArgumentsLength","Affine","forwardMatrix","invertAffineMatrix","hasPartialDerivatives","hasConstantPartialDerivatives","controlPoints","leastSquares","u","v","addTerms","solve","getVectors","concat","determinant","assign","InvalidArgument","Arc","c0","c1","c2","c3","c4","angleToWidth","radiusToHeight","forceBestFit","getUV","a","ca","cos","sa","sin","vp","atan2","hypot","q","Perspective","reverseMatrix","denominator","invertPerspectiveMatrix","inverse","validity","absR","absC6","absC7","pow","exception","Filter","filterFunction","windowingFunction","support","blur","windowSupport","xBlur","window","filter","box","func","filterFunctionName","cubicBC","b","p0","p2","p3","q0","q1","q2","q3","filterFunctions","vpx","BACKGROUND","EDGE","MIRROR","RANDOM","TILE","TRANSPARENT","BLACK","GRAY","WHITE","HORIZONTAL_TILE","VERTICAL_TILE","HORIZONTAL_TILE_EDGE","VERTICAL_TILE_EDGE","getEdgeCoords","getTileCoords","rx","ry","virtualPixelTrait","getVirtualPixelColor","method","vpxMethods","backgroundColor","getImagePixelColor","tx","ty","quantumRange","random","interpolation","AVERAGE","AVERAGE_9","AVERAGE_16","INTEGER","interpolationTrait","getInterpolatedPixelColor","interpolationMethod","methods","interpolateAverage","getPixelColor","startX","startY","count","endX","endY","color","Y","X","gamma","notImplemented","AbstractImage","virtualPixelMethod","setImagePixelColor","blank","prepareBlank","resized","resize","Canvas","imageData","getContext","getImageData","data","offset","document","createElement","putImageData","drawImage","dst","DomImage","Image","onload","src","toDataURL","sync","mixins","clampToQuantum","clampEllipseAxes","dux","duy","dvx","dvy","n11","n12","n21","n22","det","twice_det","frobenius_squared","discriminant","sqrt_discriminant","sqrt","s1s1","s2s2","s1s1minusn11","s1s1minusn22","s1s1minusn11_squared","s1s1minusn22_squared","temp_u11","temp_u21","norm","u11","u21","major_mag","minor_mag","EWA","resizeFilter","matteColor","weightLookupTable","table","rScale","Q","getWeight","buildWeightLookupTable","imageViewport","imageArea","imageVirtualPixelMethod","imageAverageColor","A","B","C","F","uLimit","vLimit","uWidth","slope","ellipseIsSetUp","limitReached","getValidity","reverseMap","setupEllipseOnce","getPartialDerivatives","setupEllipse","getWeightedAverage","area","derivatives","derivative","initEllipse","scaleEllipse","major_x","major_y","minor_x","minor_y","u0","v0","doesntNeedResampling","getImageAverageColor","divisorM","divisorC","red","green","blue","alpha","uw","DDQ","ustart","uend","U","V","DQ","weight","g","outOfImageBounds","getAverageColor","Point","util","utils","gaussJordanElimination","filterPresets","ROBIDOUX","ROBIDOUX_SHARP","defaultOptions","resample","distorted","scaleSupersampled","supersampled","console","warn","makeOptions","options","supersample","makeDistorter","dist","makeResampler","rsm","makeFilter","distorts","AFFINE","fromControlPoints","AFFINE_PROJECTION","sx","sy","fromForwardMatrix","PERSPECTIVE","PERSPECTIVE_PROJECTION","ARC","fromArguments","lens","VERSION","process","EPSILON","distort","e","reject","registerDistortionResolver","resolver","unregisterDistortionResolver"],"mappings":"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","file":"lens.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lens\"] = factory();\n\telse\n\t\troot[\"lens\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * Reverse pixel mapping.\r\n *\r\n * @memberOf lens.distorter\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#mapping Reverse pixel mapping details at ImageMagick docs}\r\n * @tutorial 02.02.reverse-pixel-mapping\r\n */\r\nclass ReversePixelMapping {\r\n\r\n  /**\r\n   *\r\n   * @param {ImageInterface} image Image to be distorted.\r\n   * @param {DistortionInterface} distortion Distortion to be performed.\r\n   * @param {ResamplerInterface} resampler Color resampler.\r\n   */\r\n  constructor(image, distortion, resampler) {\r\n    /**\r\n     * Image being distorted.\r\n     * @type {ImageInterface}\r\n     */\r\n    this.image = image;\r\n\r\n    /**\r\n     * Distortion.\r\n     * @type {DistortionInterface}\r\n     */\r\n    this.mapper = distortion;\r\n\r\n    /**\r\n     * Resampler.\r\n     * @type {ResamplerInterface}\r\n     */\r\n    this.resampler = resampler;\r\n\r\n    /**\r\n     * If set to true, try to calculate best fit viewport.\r\n     * @type {boolean}\r\n     */\r\n    this.bestFit = false;\r\n\r\n    /**\r\n     * Override output viewport.\r\n     * @type {lens.Viewport|null}\r\n     */\r\n    this.viewport = null;\r\n\r\n    /**\r\n     * Run distortion async.\r\n     * @type {boolean}\r\n     */\r\n    this.async = true;\r\n\r\n    /**\r\n     * Output image scaling.\r\n     * @type {number}\r\n     */\r\n    this.outputScaling = 1;\r\n  }\r\n\r\n  /**\r\n   * Distorts image.\r\n   *\r\n   * @returns {Promise<ImageInterface>|ImageInterface} New instance of ImageInterface with distorted image or Promise\r\n   * that resolves distorted ImageInterface instance.\r\n   */\r\n  distort() {\r\n    this.resampler.setImage(this.image);\r\n    this.resampler.setMapper(this.mapper);\r\n\r\n    const viewport = this.prepareViewport();\r\n    const x1 = Math.floor(viewport.x1);\r\n    const y1 = Math.floor(viewport.y1);\r\n    const x2 = Math.floor(viewport.x2);\r\n    const y2 = Math.floor(viewport.y2);\r\n\r\n    const canvas = this.image.getBlank(viewport);\r\n\r\n    this.resampler.scaling = 1 / this.outputScaling;\r\n\r\n    if (canvas instanceof Promise) {\r\n      return canvas.then(canvas => this.performDistortionAsync(canvas, x1, y1, x2, y2));\r\n    } else if (this.async) {\r\n      return this.performDistortionAsync(canvas, x1, y1, x2, y2);\r\n    }\r\n\r\n    return this.performDistortion(canvas, x1, y1, x2, y2);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {ImageInterface} canvas\r\n   * @param {number} x1\r\n   * @param {number} y1\r\n   * @param {number} x2\r\n   * @param {number} y2\r\n   * @returns {ImageInterface}\r\n   */\r\n  performDistortion(canvas, x1, y1, x2, y2) {\r\n    for (let y = y1; y <= y2; y++) {\r\n      for (let x = x1; x <= x2; x++) {\r\n        canvas.setPixelColor(x, y, this.resampler.getResampledColor(x + 0.5, y + 0.5));\r\n      }\r\n    }\r\n\r\n    return canvas;\r\n  }\r\n\r\n  performDistortionAsync(...args) {\r\n    return new Promise(resolve => setTimeout(() => resolve(this.performDistortion(...args), 0)));\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @returns {lens.Viewport}\r\n   */\r\n  prepareViewport() {\r\n    let viewport;\r\n\r\n    if (this.viewport) {\r\n      viewport = this.viewport.clone();\r\n    } else if (this.bestFit && this.mapper.hasBestFitViewport) {\r\n      viewport = this.mapper.getBestFitViewport(this.image.viewport);\r\n    } else {\r\n      viewport = this.image.viewport.clone();\r\n    }\r\n\r\n    viewport.scale(this.outputScaling);\r\n\r\n    return viewport;\r\n  }\r\n}\r\n\r\nexport default ReversePixelMapping;","import ReversePixelMapping from './reverse-pixel-mapping';\r\n\r\n/**\r\n * Distorter namespace\r\n * @namespace lens.distorter\r\n */\r\nconst distorter = {\r\n  ReversePixelMapping\r\n};\r\n\r\nexport default distorter;","/**\r\n * Base Lens exception\r\n *\r\n * @extends Error\r\n * @memberOf lens.exception\r\n */\r\nclass LensException extends Error {\r\n\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'LensException';\r\n\r\n    if (typeof Error.captureStackTrace === 'function') {\r\n      Error.captureStackTrace(this, this.constructor);\r\n    } else {\r\n      this.stack = (new Error(message)).stack;\r\n    }\r\n  }\r\n}\r\n\r\nexport default LensException;","import LensException from './lens-exception';\r\n\r\n/**\r\n * Exception for unsolvable matrix in Gauss-Jordan elimination\r\n *\r\n * @extends lens.exception.LensException\r\n * @memberOf lens.exception\r\n */\r\nclass UnsolvableMatrix extends LensException {\r\n\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'UnsolvableMatrix';\r\n  }\r\n}\r\n\r\nexport default UnsolvableMatrix;","/**\r\n * @type {number}\r\n * @memberOf lens\r\n */\r\nconst EPSILON = 1.0e-12;\r\n/**\r\n * @type {number}\r\n * @memberOf lens\r\n */\r\nconst MAXIMUM_VALUE = 1.79769313486231570E+308;\r\n\r\n/**\r\n * Pi/2\r\n *\r\n * @type {number}\r\n * @memberOf lens\r\n */\r\nconst M_PI2 = Math.PI / 2;\r\n\r\n/**\r\n * Pi * 2\r\n *\r\n * @memberOf lens\r\n * @type {number}\r\n */\r\nconst M_2PI = Math.PI * 2;\r\n\r\nexport {\r\n  EPSILON,\r\n  MAXIMUM_VALUE,\r\n  M_PI2,\r\n  M_2PI\r\n};","import {EPSILON} from \"../constants\";\r\n\r\n/**\r\n * Return 1/x where x is perceptible (not unlimited or infinitesimal).\r\n *\r\n * @memberOf lens.util\r\n * @param {number} x\r\n * @returns {number}\r\n * @see {@link https://imagemagick.org/api/MagickCore/pixel-accessor_8h_source.html#l00234 PerceptibleReciprocal()}\r\n * at ImageMagick source.\r\n */\r\nfunction perceptibleReciprocal(x) {\r\n  const sign = x < 0 ? -1 : 1;\r\n\r\n  if (sign * x >= EPSILON) {\r\n    return 1 / x;\r\n  }\r\n\r\n  return sign / EPSILON;\r\n}\r\n\r\n/**\r\n * Blends two colors by given weights.\r\n *\r\n * @memberOf lens.util\r\n * @param {Color} color1 First color to blend.\r\n * @param {number} weight1 First color's weight.\r\n * @param {Color} color2 Second color to blend.\r\n * @param {number|null} [weight2] Second color's weight. If not passed -- will be calculated as 1 - weight1.\r\n * @returns {Color} Color blending result.\r\n */\r\nfunction blendColors(color1, weight1, color2, weight2 = null) {\r\n  if (weight2 === null) {\r\n    weight2 = 1 - weight1;\r\n  }\r\n\r\n  return color1.map((channel, i) => Math.round(channel * weight1 + color2[i] * weight2));\r\n}\r\n\r\n/**\r\n * Converts radians to degrees\r\n *\r\n * @memberOf lens.util\r\n * @param {number} radians\r\n * @returns {number}\r\n */\r\nfunction rad2deg(radians) {\r\n  return 180 * radians / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts degrees to radians\r\n *\r\n * @memberOf lens.util\r\n * @param {number} degrees\r\n * @returns {number}\r\n */\r\nfunction deg2rad(degrees) {\r\n  return Math.PI * degrees / 180;\r\n}\r\n\r\nexport {\r\n  blendColors,\r\n  perceptibleReciprocal,\r\n  rad2deg,\r\n  deg2rad\r\n};","import UnsolvableMatrix from '../../exception/unsolvable-matrix';\r\nimport {perceptibleReciprocal} from \"../util\";\r\n\r\n/**\r\n * @private\r\n * @param {Array} array\r\n * @param {number} row1\r\n * @param {number} col1\r\n * @param {number} row2\r\n * @param {number} col2\r\n */\r\nfunction swap(array, row1, col1, row2, col2) {\r\n  if (array[row1][col1] !== array[row2][col2]) {\r\n    array[row1][col1] += array[row2][col2];\r\n    array[row2][col2] = array[row1][col1] - array[row2][col2];\r\n    array[row1][col1] -= array[row2][col2];\r\n  }\r\n}\r\n\r\nfunction unsolvable() {\r\n  throw new UnsolvableMatrix(\"Can't solve given matrix using Gauss-Jordan method\");\r\n}\r\n\r\n/**\r\n * @summary Solves system of equations using Gauss-Jordan elimination.\r\n *\r\n * @description <p>Brings the matrix to reduced row echelon form,\r\n *  while simultaneously reducing and thus solving the augmented results\r\n *  matrix.</p>\r\n *\r\n * <p>See also {@link http://en.wikipedia.org/wiki/Gauss-Jordan_elimination}</p>\r\n *\r\n *\r\n *  <p>Note that the 'matrix' is given as a 'array of arrays' of rank size.\r\n *  That is values can be assigned as   matrix[row][column]   where 'row' is\r\n *  typically the equation, and 'column' is the term of the equation.\r\n *  That is the matrix is in the form of a 'row first array'.</p>\r\n *\r\n *  <p>However 'vectors' is a 'array of arrays' which can have any number\r\n *  of columns, with each column array the same 'rank' size as 'matrix'.</p>\r\n *\r\n *  <p>This allows for simpler handling of the results, especially is only one\r\n *  column 'vector' is all that is required to produce the desired solution.</p>\r\n *\r\n *  <p>For example, the 'vectors' can consist of simple array of\r\n *  numbers.  when only one set of simultaneous equations is to be solved from\r\n *  the given set of coefficient weighted terms.</p>\r\n *\r\n *  <p>However by specifying more 'columns' (as an 'array of vector columns',\r\n *  you can use this function to solve a set of 'separable' equations.</p>\r\n *\r\n *  <p>For example a distortion function where    <code>u = U(x,y)  v = V(x,y)</code>\r\n *  And the functions U() and V() have separate coefficients, but are being\r\n *  generated from a common x,y->u,v  data set.</p>\r\n *\r\n *  <p>You can also use the 'vectors' to generate an inverse of the given 'matrix'\r\n *  though as a 'column first array' rather than a 'row first array'. For\r\n *  details see {@link http://en.wikipedia.org/wiki/Gauss-Jordan_elimination}</p>\r\n *\r\n * @memberOf lens.util.gaussJordanElimination\r\n *\r\n * @see {@link https://imagemagick.org/api/MagickCore/matrix_8c_source.html#l00480 GaussJordanElimination()} at\r\n * ImageMagick source.\r\n */\r\nclass Solver {\r\n\r\n  /**\r\n   *\r\n   * @param {Array<number[]>} matrix Square matrix to be solved.\r\n   * @param {Array<number[]>} vectors Augment results matrix.\r\n   */\r\n  constructor(matrix, vectors) {\r\n    this.solved = false;\r\n    this.matrix = matrix.map(row => row.slice());\r\n    this.vectors = vectors.map(vector => vector.slice());\r\n  }\r\n\r\n  /**\r\n   * Solves given matrix.\r\n   *\r\n   * @returns {lens.util.gaussJordanElimination.Solver}\r\n   */\r\n  solve() {\r\n    if (this.solved) {\r\n      return this;\r\n    }\r\n\r\n    this.validate();\r\n\r\n    const matrix = this.matrix;\r\n    const vectors = this.vectors;\r\n    const rank = matrix.length;\r\n    const numVectors = vectors.length;\r\n    const cols = new Array(rank).fill(0);\r\n    const rows = new Array(rank).fill(0);\r\n    const pivots = new Array(rank).fill(0);\r\n    let col = 0;\r\n    let row = 0;\r\n\r\n    for (let i = 0; i < rank; i++) {\r\n      let max = 0;\r\n\r\n      for (let j = 0; j < rank; j++) {\r\n        if (pivots[j] !== 1) {\r\n          for (let k = 0; k < rank; k++) {\r\n            if (pivots[k] !== 0) {\r\n              if (pivots[k] > 1) {\r\n                unsolvable();\r\n              }\r\n            } else if (Math.abs(matrix[j][k]) >= max) {\r\n              max = Math.abs(matrix[j][k]);\r\n              row = j;\r\n              col = k;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      pivots[col]++;\r\n\r\n      if (row !== col) {\r\n        for (let k = 0; k < rank; k++) {\r\n          swap(matrix, row, k, col, k);\r\n        }\r\n\r\n        for (let k = 0; k < numVectors; k++) {\r\n          swap(vectors, k, row, k, col);\r\n        }\r\n      }\r\n\r\n      rows[i] = row;\r\n      cols[i] = col;\r\n\r\n      if (matrix[col][col] === 0) {\r\n        unsolvable();\r\n      }\r\n\r\n      let scale = perceptibleReciprocal(matrix[col][col]);\r\n      matrix[col][col] = 1;\r\n\r\n      for (let j = 0; j < rank; j++) {\r\n        matrix[col][j] *= scale;\r\n      }\r\n\r\n      for (let j = 0; j < numVectors; j++) {\r\n        vectors[j][col] *= scale;\r\n      }\r\n\r\n      for (let j = 0; j < rank; j++) {\r\n        if (j !== col) {\r\n          let scale = matrix[j][col];\r\n          matrix[j][col] = 0;\r\n\r\n          for (let k = 0; k < rank; k++) {\r\n            matrix[j][k] -= scale * matrix[col][k];\r\n          }\r\n\r\n          for (let k = 0; k < numVectors; k++) {\r\n            vectors[k][j] -= scale * vectors[k][col];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let j = rank - 1; j >= 0; j--) {\r\n      if (cols[j] !== rows[j]) {\r\n        for (let i = 0; i < rank; i++) {\r\n          swap(matrix, i, rows[j], i, cols[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.solved = true;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns augment matrix (results)\r\n   *\r\n   * @returns {Array.<number[]>}\r\n   */\r\n  getVectors() {\r\n    return this.vectors.map(vector => vector.slice());\r\n  }\r\n\r\n\r\n  /**\r\n   * Validates matrix and vectors.\r\n   * @protected\r\n   * @returns {lens.util.gaussJordanElimination.Solver}\r\n   */\r\n  validate() {\r\n    const rank = this.matrix.length;\r\n\r\n    this.matrix.forEach(row => {\r\n      if (row.length !== rank) {\r\n        throw new Error('Matrix must be square');\r\n      }\r\n    });\r\n\r\n    this.vectors.forEach(vector => {\r\n      if (vector.length !== rank) {\r\n        throw new Error('Vectors must be the same length as matrix rank');\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Solver;","import Solver from './solver';\r\n\r\n/**\r\n * @summary Solves system of equations using Least Squares method.\r\n * @memberOf lens.util.gaussJordanElimination\r\n * @see {@link https://imagemagick.org/api/MagickCore/matrix_8c_source.html#l00829 LeastSquaresAddTerms()} at\r\n * ImageMagick source.\r\n */\r\nclass LeastSquares extends Solver {\r\n\r\n  /**\r\n   *\r\n   * @param {number} rank The rank or size of the dimensions of the square matrix.\r\n   * Also the length of vectors, and number of terms being added.\r\n   * @param {number} numVectors Number of result vectors, and number or results being\r\n   * added.  Also represents the number of separable systems of equations\r\n   * that is being solved.\r\n   */\r\n  constructor(rank, numVectors = 1) {\r\n    const matrix = [];\r\n    const vectors = [];\r\n\r\n    for (let i = 0; i < rank; i++) {\r\n      matrix.push(new Array(rank).fill(0));\r\n    }\r\n\r\n    for (let i = 0; i < numVectors; i++) {\r\n      vectors.push(new Array(rank).fill(0));\r\n    }\r\n\r\n    super(matrix, vectors);\r\n  }\r\n\r\n  /**\r\n   * Adds one set of terms and associate results to the\r\n   * given matrix and vectors for solving using least-squares function fitting.\r\n   *\r\n   * @param {number[]} terms The pre-calculated terms (without the unknown coefficient\r\n   * weights) that forms the equation being added.\r\n   * @param {number[]} results The result(s) that should be generated from the given terms\r\n   * weighted by the yet-to-be-solved coefficients.\r\n   * @returns {lens.util.gaussJordanElimination.LeastSquares}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/matrix_8c_source.html#l00829 LeastSquaresAddTerms()} at\r\n   * ImageMagick source.\r\n   */\r\n  addTerms(terms, results) {\r\n    const rank = this.matrix.length;\r\n\r\n    for (let j = 0; j < rank; j++) {\r\n      for (let i = 0; i < rank; i++) {\r\n        this.matrix[i][j] += terms[i] * terms[j];\r\n      }\r\n\r\n      for (let i = 0; i < this.vectors.length; i++) {\r\n        this.vectors[i][j] += results[i] * terms[j];\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default LeastSquares;","/**\r\n * @summary Virtual viewport class.\r\n *\r\n * @description Represents image's virtual position at it's coordinate space.\r\n *\r\n * @memberOf lens\r\n * @see {@link https://www.imagemagick.org/Usage/basics/#page Virtual canvas offset} at ImageMagick docs.\r\n * @tutorial 02.06.virtual-viewport\r\n */\r\nclass Viewport {\r\n  /**\r\n   *\r\n   * @param {number} x1 Left edge coordinate of viewport.\r\n   * @param {number} y1 Top edge coordinate  of viewport.\r\n   * @param {number} x2 Right edge coordinate of viewport.\r\n   * @param {number} y2 Bottom edge coordinate of viewport.\r\n   */\r\n  constructor(x1, y1, x2, y2) {\r\n    /**\r\n     * Left edge coordinate of viewport.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.x1 = x1;\r\n\r\n    /**\r\n     * Top edge coordinate of viewport.\r\n     * @type {number}\r\n     */\r\n    this.y1 = y1;\r\n\r\n    /**\r\n     * Right edge coordinate of viewport.\r\n     * @type {number}\r\n     */\r\n    this.x2 = x2;\r\n\r\n    /**\r\n     * Bottom edge coordinate of viewport.\r\n     * @type {number}\r\n     */\r\n    this.y2 = y2;\r\n  }\r\n\r\n  /**\r\n   * Returns virtual viewport width -- same as image actual width.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  width() {\r\n    return this.x2 - this.x1 + 1;\r\n  }\r\n\r\n  /**\r\n   * Returns virtual viewport height -- same as image actual height.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  height() {\r\n    return this.y2 - this.y1 + 1;\r\n  }\r\n\r\n  /**\r\n   * Returns viewport area.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  area() {\r\n    return this.width() * this.height();\r\n  }\r\n\r\n  /**\r\n   * Checks if viewport contains given coords.\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {boolean}\r\n   */\r\n  contains(x, y) {\r\n    return x >= this.x1 && x <= this.x2 && y >= this.y1 && y <= this.y2;\r\n  }\r\n\r\n  /**\r\n   * Expands viewport to contain given coords.\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {lens.Viewport}\r\n   */\r\n  expand(x, y) {\r\n    this.x1 = Math.min(this.x1, x);\r\n    this.x2 = Math.max(this.x2, x);\r\n    this.y1 = Math.min(this.y1, y);\r\n    this.y2 = Math.max(this.y2, y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clones viewport into new instance.\r\n   *\r\n   * @returns {lens.Viewport}\r\n   */\r\n  clone() {\r\n    return new this.constructor(this.x1, this.y1, this.x2, this.y2);\r\n  }\r\n\r\n  /**\r\n   * Fix bounds after best fit viewport calculation.\r\n   *\r\n   * @returns {lens.Viewport}\r\n   */\r\n  fixBounds() {\r\n    this.x1 = Math.floor(this.x1 - 0.5);\r\n    this.y1 = Math.floor(this.y1 - 0.5);\r\n    this.x2 = Math.ceil(this.x2 - 0.5);\r\n    this.y2 = Math.ceil(this.y2 - 0.5);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales viewport bounds.\r\n   *\r\n   * @param {number} scale\r\n   * @returns {lens.Viewport}\r\n   */\r\n  scale(scale) {\r\n    this.x1 = Math.round(this.x1 * scale);\r\n    this.y1 = Math.round(this.y1 * scale);\r\n    this.x2 = Math.round(this.x2 * scale);\r\n    this.y2 = Math.round(this.y2 * scale);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resets viewport offset.\r\n   *\r\n   * @returns {lens.Viewport}\r\n   */\r\n  reset() {\r\n    let width = this.width(),\r\n        height = this.height();\r\n    this.x1 = 0;\r\n    this.y1 = 0;\r\n    this.x2 = this.x1 + width - 1;\r\n    this.y2 = this.y1 + height - 1;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets viewport offset\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {lens.Viewport}\r\n   */\r\n  offset(x, y) {\r\n    this.x1 += x;\r\n    this.y1 += y;\r\n    this.x2 += x;\r\n    this.y2 += y;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Viewport;","import Viewport from \"../viewport\";\r\n\r\n/**\r\n * Mixin for classes implementing {@link DistortionInterface} that can calculate best fit viewport using forward\r\n * pixel mapping of image corners.\r\n *\r\n * @memberOf lens.mixins\r\n * @mixin\r\n */\r\nconst createsBestFitViewportFromApexes = {\r\n  /**\r\n   * Returns best fit viewport for distortion, using forward mapping for image apexes (corners).\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @returns {lens.Viewport}\r\n   */\r\n  getBestFitViewport(viewport) {\r\n    const u1 = viewport.x1,\r\n      v1 = viewport.y1,\r\n      u2 = viewport.x2 + 1,\r\n      v2 = viewport.y2 + 1,\r\n      [x, y] = this.forwardMap(u1, v1),\r\n      bestFit = new Viewport(x, y, x, y);\r\n\r\n    [[u2, v1], [u2, v2], [u1, v2]].forEach(apex => bestFit.expand(...this.forwardMap(...apex)));\r\n\r\n    bestFit.fixBounds();\r\n\r\n    return bestFit;\r\n  }\r\n};\r\n\r\nexport default createsBestFitViewportFromApexes;","import LensException from './lens-exception';\r\n\r\n/**\r\n * Exception for cases when invalid number of arguments passed\r\n *\r\n * @extends lens.exception.LensException\r\n * @memberOf lens.exception\r\n */\r\nclass InvalidArgumentsLength extends LensException {\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'InvalidArgumentsLength';\r\n  }\r\n}\r\n\r\nexport default InvalidArgumentsLength;","import LeastSquares from \"../util/gauss-jordan-elimination/least-squares\";\r\nimport createsBestFitViewportFromApexes from '../mixins/creates-best-fit-viewport-from-apexes';\r\nimport InvalidArgumentsLength from '../exception/invalid-arguments-length';\r\nimport {perceptibleReciprocal} from \"../util/util\";\r\n\r\n/**\r\n * Project coordinates using projection matrix.\r\n *\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number[]} matrix Affine matrix.\r\n * @returns {Point} Mapped coords pair.\r\n */\r\nfunction map(x, y, matrix) {\r\n  return [\r\n    matrix[0] * x + matrix[1] * y + matrix[2],\r\n    matrix[3] * x + matrix[4] * y + matrix[5]\r\n  ];\r\n}\r\n\r\n/**\r\n * Affine distortion.\r\n *\r\n * @implements {DistortionInterface}\r\n * @memberOf lens.distortion\r\n * @mixes lens.mixins.createsBestFitViewportFromApexes\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#affine Affine distortion details at ImageMagick docs}\r\n * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l02443 Affine distortion at ImageMagick source}\r\n * @tutorial 03.01.affine\r\n */\r\nclass Affine {\r\n  /**\r\n   *\r\n   * @param {number[]} matrix Affine matrix.\r\n   */\r\n  constructor(matrix) {\r\n    this.matrix = matrix;\r\n    this.forwardMatrix = this.constructor.invertAffineMatrix(matrix);\r\n    this.hasPartialDerivatives = true;\r\n    this.hasConstantPartialDerivatives = true;\r\n    this.hasBestFitViewport = true;\r\n  }\r\n\r\n  /**\r\n   * Creates affine distortion using control points array.\r\n   *\r\n   * @param {number[]} controlPoints Mappings of control points [u0, v0, x0, y0, ... , un, vn, xn, yn] where\r\n   * (u*, v*) are source (x, y) point and (x*, y*) are destination (x, y) point\r\n   * @returns {lens.distortion.Affine}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00501 Generating affine distortion matrix from control points at ImageMagick source}\r\n   */\r\n  static fromControlPoints(controlPoints) {\r\n    if (controlPoints.length % 4 !== 0) {\r\n      throw new InvalidArgumentsLength(`Number of arguments must be multiple of 4 and at least 4 arguments (1 control point) expected. ${controlPoints.length} arguments given.`);\r\n    }\r\n\r\n    /*\r\n     * handle special cases of not enough arguments\r\n     */\r\n    if (controlPoints.length === 4) {\r\n      // Only 1 CP Set Given\r\n      return new Affine([\r\n        1, 0, controlPoints[0] - controlPoints[2],\r\n        0, 1, controlPoints[1] - controlPoints[3]\r\n      ]);\r\n    } else {\r\n      // 2 or more points (usally 3) given.\r\n      // Solve a least squares simultaneous equation for coefficients.\r\n      const leastSquares = new LeastSquares(3, 2);\r\n\r\n      for (let i = 0; i < controlPoints.length; i += 4) {\r\n        let [u, v, x, y] = controlPoints.slice(i, i + 4);\r\n\r\n        leastSquares.addTerms([\r\n          x, y, 1\r\n        ], [u, v]);\r\n      }\r\n\r\n      if (controlPoints.length === 8) {\r\n        /*\r\n         * Only two pairs were given, but we need 3 to solve the affine.\r\n         * Fake extra coordinates by rotating p1 around p0 by 90 degrees.\r\n         * x2 = x0 - (y1-y0)   y2 = y0 + (x1-x0)\r\n         */\r\n        leastSquares.addTerms(\r\n          [\r\n            controlPoints[2] - (controlPoints[7] - controlPoints[3]),\r\n            controlPoints[3] + (controlPoints[6] - controlPoints[2]),\r\n            1\r\n          ],\r\n          [\r\n            controlPoints[0] - controlPoints[5] + controlPoints[1],\r\n            controlPoints[1] + controlPoints[4] - controlPoints[0]\r\n          ]\r\n        );\r\n      }\r\n\r\n      const vectors = leastSquares.solve().getVectors();\r\n\r\n      return new Affine(vectors[0].concat(vectors[1]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates affine distortion using affine matrix.\r\n   *\r\n   * @param {number[]} matrix Affine projection coefficients: [sx, rx, tx, ry, sy, ty]\r\n   * @returns {lens.distortion.Affine}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00609 Generating inverted affine distortion matrix from forward affine matrix at ImageMagick source}\r\n   */\r\n  static fromForwardMatrix(matrix) {\r\n    // TODO: trap test for sx*sy-rx*ry == 0 (determinant = 0, no inverse)\r\n\r\n    return new Affine(this.invertAffineMatrix(matrix));\r\n  }\r\n\r\n  /**\r\n   * Creates inverted affine matrix from affine matrix.\r\n   *\r\n   * @param {number[]} matrix Affine matrix.\r\n   * @returns {number[]} Inverted affine matrix.\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00095 Inverting affine matrix at ImageMagick source}\r\n   */\r\n  static invertAffineMatrix(matrix) {\r\n    /* From \"Digital Image Warping\" by George Wolberg, page 50 */\r\n\r\n    const determinant = perceptibleReciprocal(matrix[0] * matrix[4] - matrix[1] * matrix[3]);\r\n\r\n    return [\r\n      determinant * matrix[4],\r\n      determinant * (-matrix[1]),\r\n      determinant * (matrix[1] * matrix[5] - matrix[2] * matrix[4]),\r\n      determinant * (-matrix[3]),\r\n      determinant * matrix[0],\r\n      determinant * (matrix[2] * matrix[3] - matrix[0] * matrix[5])\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  reverseMap(x, y) {\r\n    return map(x, y, this.matrix);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getValidity(x, y) {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPartialDerivatives(x, y) {\r\n    return [\r\n      this.matrix[0],\r\n      this.matrix[1],\r\n      this.matrix[3],\r\n      this.matrix[4]\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Maps source coords into destination coords.\r\n   *\r\n   * @param {number} x X-coordinate of source image point.\r\n   * @param {number} y Y-coordinate of source image point.\r\n   * @returns {Point} Forward mapped destination image coords.\r\n   */\r\n  forwardMap(x, y) {\r\n    return map(x, y, this.forwardMatrix);\r\n  }\r\n}\r\n\r\nObject.assign(Affine.prototype, createsBestFitViewportFromApexes);\r\n\r\nexport default Affine;","import LensException from './lens-exception';\r\n\r\n/**\r\n * Invalid Argument Exception.\r\n *\r\n * @memberOf lens.exception\r\n * @extends lens.exception.LensException\r\n */\r\nclass InvalidArgument extends LensException {\r\n  /**\r\n   *\r\n   * @param {string} message\r\n   */\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'InvalidArgument';\r\n  }\r\n}\r\n\r\nexport default InvalidArgument;","import {EPSILON, M_PI2, M_2PI} from \"../constants\";\r\nimport {InvalidArgument} from \"../exception\";\r\nimport {deg2rad} from \"../util\";\r\nimport Viewport from '../viewport';\r\n\r\n/**\r\n * @summary Arc distortion.\r\n *\r\n * @description Note the coefficients use a center angle, so asymptotic join is\r\n * furthest from both sides of the source image. This also means that\r\n * for arc angles greater than 360 the sides of the image will be\r\n * trimmed equally.\r\n *\r\n * @memberOf lens.distortion\r\n * @implements DistortionInterface\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#arc Arc distortion details} at ImageMagick docs.\r\n * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l02561 Arc distortion} at ImageMagick\r\n * source.\r\n * @tutorial 03.03.arc\r\n */\r\nclass Arc {\r\n  /**\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @param {number} c0 Angle for center of source image.\r\n   * @param {number} c1 Angle scale for mapping to source image.\r\n   * @param {number} c2 Radius for top of source image.\r\n   * @param {number} c3 Radius scale for mapping source image.\r\n   * @param {number} c4 Center line of arc within source image.\r\n   */\r\n  constructor(viewport, c0, c1, c2, c3, c4) {\r\n    this.viewport = viewport;\r\n    this.c0 = c0;\r\n    this.c1 = c1;\r\n    this.c2 = c2;\r\n    this.c3 = c3;\r\n    this.c4 = c4;\r\n\r\n    /*\r\n     * Convert the angle_to_width and radius_to_height\r\n     * to appropriate scaling factors, to allow faster processing\r\n     * in the mapping function.\r\n     */\r\n    this.angleToWidth = M_2PI * this.viewport.width() / this.c1;\r\n    this.radiusToHeight = this.viewport.height() / this.c3;\r\n\r\n    this.hasPartialDerivatives = true;\r\n    this.hasConstantPartialDerivatives = false;\r\n    this.hasBestFitViewport = true;\r\n    this.forceBestFit = true;\r\n  }\r\n\r\n  /**\r\n   * @summary Creates arc distortion class from arguments.\r\n   *\r\n   * @description Arguments:  [angle, rotation, outer_radius, inner_radius]\r\n   * All but first argument are optional.\r\n   *\r\n   * By default, if the radii arguments are nor provided the image radius\r\n   * is calculated so the horizontal center-line is fits the given arc\r\n   * without scaling.\r\n   *\r\n   * The output image size is ALWAYS adjusted to contain the whole image,\r\n   * and an offset is given to position image relative to the 0,0 point of\r\n   * the origin, allowing users to use relative positioning onto larger\r\n   * background.\r\n   *\r\n   * The arguments are converted to distortion coefficients.\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @param {number[]} args Arguments:\r\n   * * 0: **angle** - The angle over which to arc the image side-to-side.\r\n   * * 1: **rotation** - Angle to rotate image from vertical center.\r\n   * * 2: **outer_radius** - Set top edge of source image at this radius.\r\n   * * 3: **inner_radius** - Set bottom edge to this radius (radial scaling).\r\n   * @returns {lens.distortion.Arc}\r\n   * @throws {lens.exception.InvalidArgument} Thrown when first (angle) or third (outer radius) arguments are too small\r\n   *\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l01095 Generating coefficients} for arc\r\n   * distortion at ImageMagick source.\r\n   */\r\n  static fromArguments(viewport, args) {\r\n    if (args.length >= 1 && args[0] < EPSILON) {\r\n      throw new InvalidArgument('Angle too small');\r\n    }\r\n\r\n    if (args.length >= 3 && args[2] < EPSILON) {\r\n      throw new InvalidArgument('Outer radius too small');\r\n    }\r\n\r\n    let c0, c1, c2, c3, c4;\r\n\r\n    c0 = -M_PI2; // -90, place at top!\r\n\r\n    if (args.length >= 1) {\r\n      c1 = deg2rad(args[0]);\r\n    } else {\r\n      c1 = M_PI2; // zero arguments - center is at top\r\n    }\r\n\r\n    if (args.length >= 2) {\r\n      c0 += deg2rad(args[1]);\r\n    }\r\n\r\n    c0 /= M_2PI; // normalize radians\r\n    c0 -= Math.round(c0);\r\n    c0 *= M_2PI; // de-normalize back to radians\r\n\r\n    c3 = viewport.height() - 1;\r\n    c2 = viewport.width() / c1 + c3 / 2;\r\n\r\n    if (args.length >= 3) {\r\n      if (args.length >= 4) {\r\n        c3 = args[2] - args[3];\r\n      } else {\r\n        c3 *= args[2] / c2;\r\n      }\r\n\r\n      c2 = args[2];\r\n    }\r\n\r\n    c4 = (viewport.width() - 1) / 2;\r\n\r\n    return new Arc(viewport, c0, c1, c2, c3, c4);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  reverseMap(x, y) {\r\n    let [u, v] = this.getUV(x, y);\r\n\r\n    // now scale the angle and radius for source image lookup point\r\n    u = u * this.angleToWidth + this.c4 + this.viewport.x1 + 0.5;\r\n    v = (this.c2 - v) * this.radiusToHeight + this.viewport.y1;\r\n\r\n    //console.log(u, v, x, y);\r\n\r\n    return [u, v];\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getValidity(x, y) {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPartialDerivatives(x, y) {\r\n    let [u, v] = this.getUV(x, y);\r\n\r\n    /*\r\n     * Arc Distortion Partial Scaling Vectors\r\n     * Are derived by mapping the perpendicular unit vectors\r\n     * dR  and  dA*R*2PI  rather than trying to map dx and dy\r\n     * The results is a very simple orthogonal aligned ellipse.\r\n     */\r\n    if (v > EPSILON) {\r\n      return [this.angleToWidth / (M_2PI * v), 0, 0, this.radiusToHeight];\r\n    } else {\r\n      return [this.viewport.width() * 2, 0, 0, this.radiusToHeight];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns calculated best fit viewport for image.\r\n   *\r\n   * @param {lens.Viewport} viewport\r\n   * @returns {lens.Viewport}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l01834 Generating best fit viewport}\r\n   * for arc distortion at ImageMagick source.\r\n   */\r\n  getBestFitViewport(viewport) {\r\n    // Forward Map Corners\r\n    let a = this.c0 - this.c1 / 2,\r\n      ca = Math.cos(a),\r\n      sa = Math.sin(a),\r\n      x = this.c2 * ca,\r\n      y = this.c2 * sa,\r\n      vp = new Viewport(x, y, x, y);\r\n\r\n    x = (this.c2 - this.c3) * ca;\r\n    y = (this.c2 - this.c3) * sa;\r\n    vp.expand(x, y);\r\n\r\n    a = this.c0 + this.c1 / 2;\r\n    ca = Math.cos(a);\r\n    sa = Math.sin(a);\r\n    x = this.c2 * ca;\r\n    y = this.c2 * sa;\r\n    vp.expand(x, y);\r\n\r\n    x = (this.c2 - this.c3) * ca;\r\n    y = (this.c2 - this.c3) * sa;\r\n    vp.expand(x, y);\r\n\r\n    // Orthogonal points along top of arc\r\n    for (\r\n      a = Math.ceil((this.c0 - this.c1 / 2) / M_PI2) * M_PI2;\r\n      a < this.c0 + this.c1 / 2;\r\n      a += M_PI2\r\n    ) {\r\n      ca = Math.cos(a);\r\n      sa = Math.sin(a);\r\n      x = this.c2 * ca;\r\n      y = this.c2 * sa;\r\n      vp.expand(x, y);\r\n    }\r\n\r\n    vp.fixBounds();\r\n\r\n    return vp;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {Point}\r\n   */\r\n  getUV(x, y) {\r\n    let u, v;\r\n\r\n    // what is the angle and radius in the destination image\r\n    u = (Math.atan2(y, x) - this.c0) / M_2PI;\r\n    u -= Math.round(u);\r\n    v = Math.hypot(x, y);\r\n\r\n    return [u, v];\r\n  }\r\n}\r\n\r\nexport default Arc;","import LeastSquares from '../util/gauss-jordan-elimination/least-squares';\r\nimport createsBestFitViewportFromApexes from '../mixins/creates-best-fit-viewport-from-apexes';\r\nimport InvalidArgumentsLength from '../exception/invalid-arguments-length';\r\nimport {perceptibleReciprocal} from \"../util/util\";\r\n\r\n/**\r\n * Project coordinates using projection matrix\r\n *\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number[]} matrix Perspective matrix.\r\n * @returns {Point} Mapped coords pair.\r\n * @tutorial 03.02.perspective\r\n */\r\nfunction map(x, y, matrix) {\r\n  let p = matrix[0] * x + matrix[1] * y + matrix[2],\r\n    q = matrix[3] * x + matrix[4] * y + matrix[5],\r\n    r = matrix[6] * x + matrix[7] * y + 1;\r\n\r\n  return [p / r, q / r];\r\n}\r\n\r\n/**\r\n * @summary Perspective Distortion (a ratio of affine distortions).\r\n *\r\n * @description <pre>\r\n *\r\n *     p(x,y)    c0*x + c1*y + c2\r\n * u = ------ = ------------------\r\n *     r(x,y)    c6*x + c7*y + 1\r\n *\r\n *     q(x,y)    c3*x + c4*y + c5\r\n * v = ------ = ------------------\r\n *      r(x,y)    c6*x + c7*y + 1\r\n *\r\n * denominator = Sign of 'r', or the denominator affine, for the actual image.\r\n * This determines what part of the distorted image is 'ground'\r\n * side of the horizon, the other part is 'sky' or invalid.\r\n * Valid values are  +1.0  or  -1.0  only.\r\n * </pre>\r\n *\r\n * @implements {DistortionInterface}\r\n * @memberOf lens.distortion\r\n * @mixes lens.mixins.createsBestFitViewportFromApexes\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#perspective Perspective distortion details at ImageMagick docs}\r\n * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l02450 Perspective distortion at ImageMagick source}\r\n */\r\nclass Perspective {\r\n\r\n  /**\r\n   *\r\n   * @param {number[]} reverseMatrix Perspective projection matrix for reverse pixel mapping.\r\n   * @param {number} denominator Denominator for mapping validity calculation.\r\n   */\r\n  constructor(reverseMatrix, denominator) {\r\n    this.matrix = reverseMatrix;\r\n    this.denominator = denominator;\r\n    this.forwardMatrix = this.constructor.invertPerspectiveMatrix(reverseMatrix);\r\n    this.hasPartialDerivatives = true;\r\n    this.hasConstantPartialDerivatives = false;\r\n    this.hasBestFitViewport = true;\r\n  }\r\n\r\n  /**\r\n   * Creates perspective distortion using control points array.\r\n   *\r\n   * @param {number[]} controlPoints Mappings of control points [u0, v0, x0, y0, ... , un, vn, xn, yn] where\r\n   * (u*, v*) are source (x, y) point and (x*, y*) are destination (x, y) point.\r\n   * @returns {lens.distortion.Perspective} New instance.\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00745 Generating perspective distortion matrix from control points at ImageMagick source}\r\n   */\r\n  static fromControlPoints(controlPoints) {\r\n    if (controlPoints.length < 16 || controlPoints.length % 4 !== 0) {\r\n      throw new InvalidArgumentsLength(`Number of arguments must be multiple of 4 and at least 16 arguments (4 control points) expected. ${controlPoints.length} arguments given.`);\r\n    }\r\n\r\n    const leastSquares = new LeastSquares(8, 1);\r\n\r\n    for (let i = 0; i < controlPoints.length; i += 4) {\r\n      let [u, v, x, y] = controlPoints.slice(i, i + 4);\r\n\r\n      leastSquares.addTerms([\r\n        x, y, 1,\r\n        0, 0, 0,\r\n        -x * u, -y * u\r\n      ], [u])\r\n        .addTerms([\r\n          0, 0, 0,\r\n          x, y, 1,\r\n          -x * v, -y * v\r\n        ], [v]);\r\n    }\r\n\r\n    const matrix = leastSquares.solve().getVectors()[0];\r\n\r\n    /*\r\n     * Calculate denominator! The ground-sky determination.\r\n     * What is sign of the 'ground' in r() denominator affine function?\r\n     * Just use any valid image coordinate (first control point) in\r\n     * destination for determination of what part of view is 'ground'.\r\n     */\r\n    const denominator = matrix[6] * controlPoints[2] + matrix[7] * controlPoints[3] + 1 < 0 ? -1 : 1;\r\n\r\n    return new Perspective(matrix, denominator);\r\n  }\r\n\r\n  /**\r\n   * Creates perspective distortion using perspective matrix.\r\n   *\r\n   * @param {number[]} matrix Perspective matrix.\r\n   * @returns {lens.distortion.Perspective}\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00853 Generating inverted perspective distortion matrix from forward perspective matrix at ImageMagick docs}\r\n   */\r\n  static fromForwardMatrix(matrix) {\r\n    // TODO: trap test  c0*c4-c3*c1 == 0  (determinant = 0, no inverse)\r\n    const inverse = this.invertPerspectiveMatrix(matrix);\r\n\r\n    /*\r\n     * Calculate denominator! The ground-sky determination.\r\n     * What is sign of the 'ground' in r() denominator affine function?\r\n     * Just use any valid image coordinate in destination for determination.\r\n     * For a forward mapped perspective the images 0,0 coord will map to\r\n     * c2,c5 in the distorted image, so set the sign of denominator of that.\r\n     */\r\n    const denominator = inverse[6] * matrix[2] + inverse[7] * matrix[5] + 1 < 0 ? -1 : 1;\r\n    return new Perspective(inverse, denominator);\r\n  }\r\n\r\n  /**\r\n   * Creates inverted perspective matrix from perspective matrix.\r\n   *\r\n   * @param {number[]} matrix Perspective matrix.\r\n   * @returns {number[]} Inverted perspective matrix.\r\n   * @see {@link https://imagemagick.org/api/MagickCore/distort_8c_source.html#l00109 Inverting perspective matrix at ImageMagick source}\r\n   */\r\n  static invertPerspectiveMatrix(matrix) {\r\n    const determinant = perceptibleReciprocal(matrix[0] * matrix[4] - matrix[3] * matrix[1]);\r\n\r\n    return [\r\n      determinant * (matrix[4] - matrix[7] * matrix[5]),\r\n      determinant * (matrix[7] * matrix[2] - matrix[1]),\r\n      determinant * (matrix[1] * matrix[5] - matrix[4] * matrix[2]),\r\n      determinant * (matrix[6] * matrix[5] - matrix[3]),\r\n      determinant * (matrix[0] - matrix[6] * matrix[2]),\r\n      determinant * (matrix[3] * matrix[2] - matrix[0] * matrix[5]),\r\n      determinant * (matrix[3] * matrix[7] - matrix[6] * matrix[4]),\r\n      determinant * (matrix[6] * matrix[1] - matrix[0] * matrix[7])\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  reverseMap(x, y) {\r\n    return map(x, y, this.matrix);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getValidity(x, y, scaling) {\r\n    const r = this.matrix[6] * x + this.matrix[7] * y + 1;\r\n    let validity = r * this.denominator < 0 ? 0 : 1;\r\n    const absR = Math.abs(r) * 2;\r\n    const absC6 = Math.abs(this.matrix[6]);\r\n    const absC7 = Math.abs(this.matrix[7]);\r\n\r\n    if (absC6 > absC7) {\r\n      if (absR < absC6) {\r\n        validity = 0.5 - this.denominator * r / (this.matrix[6] * scaling);\r\n      }\r\n    } else if (absR < absC7) {\r\n      validity = 0.5 - this.denominator * r / (this.matrix[7] * scaling);\r\n    }\r\n\r\n    return validity;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPartialDerivatives(x, y) {\r\n    const p = this.matrix[0] * x + this.matrix[1] * y + this.matrix[2],\r\n      q = this.matrix[3] * x + this.matrix[4] * y + this.matrix[5],\r\n      r = this.matrix[6] * x + this.matrix[7] * y + 1,\r\n      scale = Math.pow(1 / r, 2);\r\n\r\n    return [\r\n      (r * this.matrix[0] - p * this.matrix[6]) * scale, // dUx\r\n      (r * this.matrix[1] - p * this.matrix[7]) * scale, // dUy\r\n      (r * this.matrix[3] - q * this.matrix[6]) * scale, // dVx\r\n      (r * this.matrix[4] - q * this.matrix[7]) * scale //dVy\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Maps source coords into destination coords.\r\n   *\r\n   * @param {number} u X-coordinate of source image point.\r\n   * @param {number} v Y-coordinate of source image point.\r\n   * @returns {Point} Forward mapped destination image coords.\r\n   */\r\n  forwardMap(u, v) {\r\n    return map(u, v, this.forwardMatrix);\r\n  }\r\n}\r\n\r\nObject.assign(Perspective.prototype, createsBestFitViewportFromApexes);\r\n\r\nexport default Perspective;","import Affine from './affine';\r\nimport Arc from './arc';\r\nimport Perspective from './perspective';\r\n\r\n/**\r\n * Distortion namespace\r\n *\r\n * @namespace lens.distortion\r\n */\r\nconst distortion = {\r\n  Affine,\r\n  Arc,\r\n  Perspective\r\n};\r\n\r\nexport default distortion;","import InvalidArgument from './invalid-argument';\r\nimport InvalidArgumentsLength from './invalid-arguments-length';\r\nimport LensException from './lens-exception';\r\nimport UnsolvableMatrix from './unsolvable-matrix';\r\n\r\n/**\r\n * Exception namespace\r\n *\r\n * @namespace lens.exception\r\n */\r\nconst exception = {\r\n  InvalidArgument,\r\n  InvalidArgumentsLength,\r\n  LensException,\r\n  UnsolvableMatrix\r\n};\r\n\r\nexport default exception;","import {EPSILON} from \"../constants\";\r\n\r\n/**\r\n * Internal filter or windowing function.\r\n *\r\n * @callback lens.filter.Filter~filterFunction\r\n * @param {number} [x]\r\n * @param {number} [support]\r\n * @param {number} [windowSupport]\r\n * @returns {number}\r\n */\r\n\r\n/**\r\n * Resample filter.\r\n *\r\n * @implements {FilterInterface}\r\n * @memberOf lens.filter\r\n * @see {@link https://www.imagemagick.org/Usage/filter/#filter Resampling Filters} at ImageMagick docs\r\n * @see {@link https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf Fundamentals of Texture Mapping and Image Warping by Paul S. Heckbert}\r\n * page 41, section 3.4, 3.5\r\n * @see {@link https://imagemagick.org/api/MagickCore/resize_8c_source.html#l00757 AquireResizeFilter at ImageMagick source}\r\n * @tutorial 02.03.pixel-color-lookup\r\n */\r\nclass Filter {\r\n\r\n  /**\r\n   *\r\n   * @param {lens.filter.Filter~filterFunction} filterFunction Filtering function.\r\n   * @param {lens.filter.Filter~filterFunction} windowingFunction Windowing function.\r\n   * @param {number} support Filter region of support - the filter support limit.\r\n   * @param {number} scale Dimension scaling to fit window support (usally 1.0).\r\n   * @param {number} [blur=1] X-scale (blur-sharpen).\r\n   * @param {number|null} [windowSupport=null] Window support, usually equal to support (expert only).\r\n   */\r\n  constructor(filterFunction, windowingFunction, support, scale, blur = 1, windowSupport = null) {\r\n    this.filterFunction    = filterFunction;\r\n    this.windowingFunction = windowingFunction;\r\n    this.support           = support;\r\n    this.scale             = scale;\r\n    this.blur              = blur;\r\n    this.windowSupport     = windowSupport !== null ? windowSupport : support;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getWeight(x) {\r\n    const xBlur = x / this.blur;\r\n    const scale = xBlur < EPSILON ? 1 : this.window(this.scale * xBlur);\r\n    return scale * this.filter(xBlur);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  filter(x) {\r\n    return this.filterFunction(x, this.support, this.windowSupport);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  window(x) {\r\n    return this.windowingFunction(x, this.support, this.windowSupport);\r\n  }\r\n}\r\n\r\nexport default Filter;","/**\r\n * @namespace lens.filter.filterFunctions\r\n */\r\n\r\n/**\r\n * Makes box filter function.\r\n * A Box filter is a equal weighting function (all weights equal).\r\n * DO NOT LIMIT results by support or resize point sampling will work\r\n * as it requests points beyond its normal 0.0 support size.\r\n *\r\n * @memberOf lens.filter.filterFuncFactories\r\n * @returns {lens.filter.Filter~filterFunction}\r\n * @see {@link https://imagemagick.org/api/MagickCore/resize_8c_source.html#l00181 Ox filter function at ImageMagick source}\r\n */\r\nfunction box() {\r\n  const func = function () {\r\n    return 1;\r\n  };\r\n\r\n  func.filterFunctionName = 'box';\r\n\r\n  return func;\r\n}\r\n\r\n/**\r\n * Makes cubicBC filter function.\r\n * <p>Cubic Filters using B,C determined values:</p>\r\n * <pre>\r\n *     Mitchell-Netravali  B = 1/3 C = 1/3  \"Balanced\" cubic spline filter\r\n *     Catmull-Rom         B = 0   C = 1/2  Interpolatory and exact on linears\r\n *     Spline              B = 1   C = 0    B-Spline Gaussian approximation\r\n *     Hermite             B = 0   C = 0    B-Spline interpolator\r\n * </pre>\r\n *\r\n * <p>See paper by Mitchell and Netravali, Reconstruction Filters in Computer\r\n * Graphics Computer Graphics, Volume 22, Number 4, August 1988\r\n * {@link http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf}.</p>\r\n *\r\n * <p>Coefficents are determined from B,C values:\r\n * <pre>\r\n *    P0 = (  6 - 2*B       )/6 = coeff[0]\r\n *    P1 =         0\r\n *    P2 = (-18 +12*B + 6*C )/6 = coeff[1]\r\n *    P3 = ( 12 - 9*B - 6*C )/6 = coeff[2]\r\n *    Q0 = (      8*B +24*C )/6 = coeff[3]\r\n *    Q1 = (    -12*B -48*C )/6 = coeff[4]\r\n *    Q2 = (      6*B +30*C )/6 = coeff[5]\r\n *    Q3 = (    - 1*B - 6*C )/6 = coeff[6]\r\n * </pre>\r\n * which are used to define the filter:\r\n * <pre>\r\n *    P0 + P1*x + P2*x^2 + P3*x^3      0 <= x < 1\r\n *    Q0 + Q1*x + Q2*x^2 + Q3*x^3      1 <= x < 2\r\n * </pre>\r\n * which ensures function is continuous in value and derivative (slope).</p>\r\n *\r\n * @memberOf lens.filter.filterFuncFactories\r\n * @see {@link https://imagemagick.org/api/MagickCore/resize_8c_source.html#l00207 CubicBC filter function at ImageMagick source}\r\n * @param {number} b\r\n * @param {number} c\r\n * @returns {lens.filter.Filter~filterFunction}\r\n */\r\nfunction cubicBC(b, c) {\r\n  const p0 = (6 - 2 * b) / 6;\r\n  // const p1 = 0;\r\n  const p2 = (-18 + 12 * b + 6 * c) / 6;\r\n  const p3 = (12 - 9 * b - 6 * c) / 6;\r\n  const q0 = (8 * b + 24 * c) / 6;\r\n  const q1 = (-12 * b - 48 * c) / 6;\r\n  const q2 = (6 * b + 30 * c) / 6;\r\n  const q3 = (-1 * b - 6 * c) / 6;\r\n\r\n  const func = function (x) {\r\n    if (x < 1) {\r\n      return p0 + x * (x * (p2 + x * p3));\r\n    } else if (x < 2) {\r\n      return q0 + x * (q1 + x * (q2 + x * q3));\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  func.filterFunctionName = 'cubicBC';\r\n  func.b = b;\r\n  func.c = c;\r\n\r\n  return func;\r\n};\r\n\r\n// TODO: add more filter functions\r\n\r\nexport {\r\n  box, cubicBC\r\n};","import Filter from './filter';\r\nimport * as filterFunctions from './filter-functions';\r\n\r\n/**\r\n * Filter namespace\r\n *\r\n * @namespace lens.filter\r\n */\r\nconst filter = {\r\n  Filter,\r\n  filterFunctions\r\n};\r\n\r\nexport default filter;","/**\r\n * Virtual pixel methods.\r\n *\r\n * @readonly\r\n * @enum {number}\r\n * @memberOf lens\r\n * @see {@link https://www.imagemagick.org/Usage/misc/#virtual-pixel Virtual pixel details} at ImageMagick docs.\r\n * @tutorial 02.05.virtual-pixels-and-matte\r\n */\r\nconst vpx = {\r\n  /**\r\n   * Use image background color.\r\n   */\r\n  BACKGROUND: 1,\r\n\r\n  /**\r\n   * Closest edge color.\r\n   */\r\n  EDGE: 3,\r\n\r\n  /**\r\n   * Mirror effect.\r\n   */\r\n  MIRROR: 4,\r\n\r\n  /**\r\n   * Random color from image.\r\n   */\r\n  RANDOM: 5,\r\n\r\n  /**\r\n   * Tile effect.\r\n   */\r\n  TILE: 6,\r\n\r\n  /**\r\n   * Transparent color.\r\n   */\r\n  TRANSPARENT: 7,\r\n\r\n  /**\r\n   * Black color.\r\n   */\r\n  BLACK: 9,\r\n\r\n  /**\r\n   * Gray color.\r\n   */\r\n  GRAY: 10,\r\n\r\n  /**\r\n   * White color.\r\n   */\r\n  WHITE: 11,\r\n\r\n  /**\r\n   * Tile effect horizontally, background color vertically.\r\n   */\r\n  HORIZONTAL_TILE: 12,\r\n\r\n  /**\r\n   * Tile effect vertically, background color horizontally.\r\n   */\r\n  VERTICAL_TILE: 13,\r\n\r\n  /**\r\n   * Tile effect horizontally, closest edge color vertically.\r\n   */\r\n  HORIZONTAL_TILE_EDGE: 14,\r\n\r\n  /**\r\n   * Tile effect vertically, closest edge color horizontally.\r\n   */\r\n  VERTICAL_TILE_EDGE: 15\r\n\r\n  // TODO: implement and add Checker tile an dither methods\r\n};\r\n\r\nexport default vpx;","import vpxMethods from '../vpx';\r\n\r\n/**\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Point}\r\n */\r\nfunction getEdgeCoords(x, y, width, height) {\r\n  return [\r\n    Math.max(0, Math.min(width - 1, x)),\r\n    Math.max(0, Math.min(height - 1, y))\r\n  ];\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Point}\r\n */\r\nfunction getTileCoords(x, y, width, height) {\r\n  let rx = x % width,\r\n    ry = y % height;\r\n\r\n  return [\r\n    rx < 0 ? width + rx : rx,\r\n    ry < 0 ? height + ry : ry\r\n  ];\r\n}\r\n\r\n/**\r\n * Adds virtual pixel behavior to classes that implement ImageInterface.\r\n *\r\n * @mixin\r\n * @memberOf lens.mixins\r\n * @tutorial 02.05.virtual-pixels-and-matte\r\n */\r\nconst virtualPixelTrait = {\r\n  /**\r\n   * Returns virtual pixel color.\r\n   *\r\n   * @param {number} x Image X-coordinate OUTSIDE of image bounds.\r\n   * @param {number} y Image Y-coordinate OUTSIDE of image bounds.\r\n   * @param {lens.vpx} method Virtual pixel method.\r\n   * @returns {Color}\r\n   */\r\n  getVirtualPixelColor(x, y, method) {\r\n    switch (method) {\r\n      case vpxMethods.BACKGROUND:\r\n        return this.backgroundColor.slice();\r\n\r\n      case vpxMethods.EDGE:\r\n        return this.getImagePixelColor(...getEdgeCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.MIRROR:\r\n        let [tx, ty] = getTileCoords(x, y, this.width * 2, this.height * 2);\r\n\r\n        if (tx > this.width - 1) {\r\n          tx = this.width - (tx - this.width) - 1;\r\n        }\r\n\r\n        if (ty > this.height - 1) {\r\n          ty = this.height - (ty - this.height) - 1;\r\n        }\r\n\r\n        return this.getImagePixelColor(tx, ty);\r\n\r\n      case vpxMethods.TILE:\r\n        return this.getImagePixelColor(...getTileCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.TRANSPARENT:\r\n      default:\r\n        return [0, 0, 0, 0];\r\n\r\n      case vpxMethods.BLACK:\r\n        return [0, 0, 0, this.quantumRange];\r\n\r\n      case vpxMethods.WHITE:\r\n        return new Array(4).fill(this.quantumRange);\r\n\r\n      case vpxMethods.GRAY:\r\n        return new Array(3).fill(Math.round(this.quantumRange / 2)).concat([this.quantumRange]);\r\n\r\n      case vpxMethods.HORIZONTAL_TILE:\r\n      case vpxMethods.HORIZONTAL_TILE_EDGE:\r\n        if (y < 0 || y >= this.height) {\r\n          return method === vpxMethods.HORIZONTAL_TILE ? this.backgroundColor.slice()\r\n            : this.getImagePixelColor(...getEdgeCoords(x, y, this.width, this.height));\r\n        }\r\n\r\n        return this.getImagePixelColor(...getTileCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.VERTICAL_TILE:\r\n      case vpxMethods.VERTICAL_TILE_EDGE:\r\n        if (x < 0 || x >= this.width) {\r\n          return method === vpxMethods.VERTICAL_TILE ? this.backgroundColor.slice()\r\n            : this.getImagePixelColor(...getEdgeCoords(x, y, this.width, this.height));\r\n        }\r\n\r\n        return this.getImagePixelColor(...getTileCoords(x, y, this.width, this.height));\r\n\r\n      case vpxMethods.RANDOM:\r\n        return this.getImagePixelColor(\r\n          Math.floor(Math.random() * this.width),\r\n          Math.floor(Math.random() * this.height)\r\n        );\r\n    }\r\n  }\r\n};\r\n\r\nexport default virtualPixelTrait;","/**\r\n * Color interpolation methods.\r\n *\r\n * @readonly\r\n * @enum {number}\r\n * @memberof lens\r\n */\r\nconst interpolation = {\r\n  /**\r\n   * Average 4 nearest neighbours.\r\n   */\r\n  AVERAGE: 1,\r\n\r\n  /**\r\n   * Average 9 nearest neighbours.\r\n   */\r\n  AVERAGE_9: 2,\r\n\r\n  /**\r\n   * Average 16 nearest neighbours.\r\n   */\r\n  AVERAGE_16: 3,\r\n\r\n  /**\r\n   * Just return background color.\r\n   */\r\n  BACKGROUND: 4,\r\n\r\n  /**\r\n   * Integer (floor) interpolation.\r\n   */\r\n  INTEGER: 8 // TODO: implement and add other methods\r\n};\r\n\r\nexport default interpolation;","import methods from '../interpolation';\r\n\r\n/**\r\n * Adds color interpolation functionality for classes that implement {@link ImageInterface}\r\n *\r\n * @mixin\r\n * @memberOf lens.mixins\r\n */\r\nconst interpolationTrait = {\r\n  /**\r\n   * Returns interpolated pixel color.\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {lens.interpolation} [interpolationMethod=this.interpolationMethod]\r\n   * @returns {Color}\r\n   */\r\n  getInterpolatedPixelColor(x, y, interpolationMethod = this.interpolationMethod) {\r\n    switch (interpolationMethod) {\r\n      case methods.AVERAGE:\r\n        return this.interpolateAverage(x, y, 2);\r\n      case methods.AVERAGE_9:\r\n        return this.interpolateAverage(x, y, 3);\r\n      case methods.AVERAGE_16:\r\n        return this.interpolateAverage(x, y, 4);\r\n      case methods.BACKGROUND:\r\n        return this.backgroundColor.slice();\r\n      case methods.INTEGER:\r\n      default:\r\n        return this.getPixelColor(Math.floor(x), Math.floor(y));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns interpolated color by average of neighbors.\r\n   *\r\n   * @private\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} count\r\n   * @returns {Color}\r\n   */\r\n  interpolateAverage(x, y, count = 2) {\r\n    let startX, startY;\r\n\r\n    switch (count) {\r\n      case 2:\r\n        startX = Math.floor(x);\r\n        startY = Math.floor(y);\r\n        break;\r\n\r\n      case 3:\r\n        startX = Math.floor(x + 0.5) - 1;\r\n        startY = Math.floor(y + 0.5) - 1;\r\n        break;\r\n      case 4:\r\n        startX = Math.floor(x) - 1;\r\n        startY = Math.floor(y) - 1;\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Param 'count' must be integer between 2 and 4.\");\r\n    }\r\n\r\n    const endX = startX + count;\r\n    const endY = startY + count;\r\n    let color = [0, 0, 0, 0];\r\n\r\n    for (let Y = startY; Y < endY; Y++) {\r\n      for (let X = startX; X < endX; X++) {\r\n        this.getPixelColor(x, y).forEach((channel, i) => color[i] += channel);\r\n      }\r\n    }\r\n\r\n    const gamma = 1 / (count * count);\r\n\r\n    return color.map(channel => Math.round(channel * gamma));\r\n  }\r\n};\r\n\r\nexport default interpolationTrait;","import Viewport from '../viewport';\r\nimport vpx from '../vpx';\r\nimport virtualPixelTrait from '../mixins/virtual-pixel-trait';\r\nimport interpolationTrait from '../mixins/interpolation-trait';\r\nimport interpolation from '../interpolation';\r\n\r\nfunction notImplemented(method) {\r\n  throw new Error(`${method}() is abstract method and must be implemented by child class`);\r\n}\r\n\r\n/**\r\n * Abstract image class for ImageInterface implementation.\r\n *\r\n * @implements {ImageInterface}\r\n * @memberOf lens.image\r\n * @abstract\r\n * @mixes lens.mixins.interpolationTrait\r\n * @mixes lens.mixins.virtualPixelTrait\r\n */\r\nclass AbstractImage {\r\n\r\n  /**\r\n   * @param {number} width Image width\r\n   * @param {number} height Image height\r\n   */\r\n  constructor(width, height) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.viewport = new Viewport(0, 0, this.width - 1, this.height - 1);\r\n    this.backgroundColor = [0, 0, 0, 0]; // Transparent;\r\n    this.virtualPixelMethod = vpx.TRANSPARENT;\r\n    this.quantumRange = 255;\r\n    this.interpolationMethod = interpolation.INTEGER;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getPixelColor(x, y) {\r\n    x = Math.floor(x - this.viewport.x1);\r\n    y = Math.floor(y - this.viewport.y1);\r\n\r\n    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\r\n      return this.getImagePixelColor(x, y);\r\n    }\r\n\r\n    return this.getVirtualPixelColor(x, y, this.virtualPixelMethod);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setPixelColor(x, y, color) {\r\n    x = Math.floor(x - this.viewport.x1);\r\n    y = Math.floor(y - this.viewport.y1);\r\n\r\n    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\r\n      this.setImagePixelColor(x, y, color);\r\n\r\n      return this;\r\n    }\r\n\r\n    throw new Error(`Given coords (${x}, ${y}) is out of image bounds`);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getBlank(viewport) {\r\n    const blank = this.prepareBlank(viewport.width(), viewport.height());\r\n\r\n    if (blank instanceof Promise) {\r\n      return blank.then(blank => {\r\n        blank.viewport  = viewport;\r\n        return blank;\r\n      });\r\n    }\r\n\r\n    blank.viewport = viewport;\r\n    return blank;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  scale(scale) {\r\n    const viewport = this.viewport.clone();\r\n    viewport.scale(scale);\r\n    const resized = this.resize(viewport.width(), viewport.height());\r\n\r\n    if (resized instanceof Promise) {\r\n      return resized.then(() => {\r\n        resized.viewport = viewport;\r\n        return resized;\r\n      });\r\n    }\r\n\r\n    resized.viewport = viewport;\r\n    return resized;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  sync() {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns pixel color at given image coords. Image coords MUST be: x  [0; width - 1], y  [0; height - 1].\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @returns {Color}\r\n   */\r\n  getImagePixelColor(x, y) {\r\n    notImplemented('getImagePixelColor');\r\n  }\r\n\r\n  /**\r\n   * Sets pixel color at given image coordinates.\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {Color} color\r\n   */\r\n  setImagePixelColor(x, y, color) {\r\n    notImplemented('setImagePixelColor');\r\n  }\r\n\r\n  /**\r\n   * Prepares blank image for {@link ImageInterface#getBlank} method.\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @returns {ImageInterface}\r\n   */\r\n  prepareBlank(width, height) {\r\n    notImplemented('prepareBlank');\r\n  }\r\n\r\n  /**\r\n   * Returns average color of whole image.\r\n   *\r\n   * @abstract\r\n   * @returns {Color}\r\n   */\r\n  getAverageColor() {\r\n    notImplemented('getAverageColor');\r\n  }\r\n\r\n  /**\r\n   * Returns resized instance of self.\r\n   *\r\n   * @abstract\r\n   * @protected\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @returns {ImageInterface|Promise<ImageInterface>}\r\n   */\r\n  resize(width, height) {\r\n    notImplemented('resize');\r\n  }\r\n}\r\n\r\nObject.assign(AbstractImage.prototype, virtualPixelTrait);\r\nObject.assign(AbstractImage.prototype, interpolationTrait);\r\n\r\nexport default AbstractImage;","import AbstractImage from './abstract-image';\r\n\r\n/**\r\n * ImageInterface implementation for distortion using HTML5 Canvas objects.\r\n * Distortion result will contain new Canvas object in {@link lens.image.Canvas#canvas} property.\r\n *\r\n * @implements {ImageInterface}\r\n * @memberOf lens.image\r\n * @extends lens.image.AbstractImage\r\n */\r\nclass Canvas extends AbstractImage {\r\n\r\n  /**\r\n   *\r\n   * @param {HTMLCanvasElement} canvas\r\n   */\r\n  constructor(canvas) {\r\n    super(canvas.width, canvas.height);\r\n    this.canvas     = canvas;\r\n    this.imageData  = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\r\n    this.data       = this.imageData.data;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getImagePixelColor(x, y) {\r\n    const offset = (y * this.width + x) * 4;\r\n\r\n    return Array.prototype.slice.call(\r\n      this.data,\r\n      offset,\r\n      offset + 4\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setImagePixelColor(x, y, color) {\r\n    const offset = (y * this.width + x) * 4;\r\n\r\n    color.forEach((channel, i) => this.data[offset + i] = channel);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  prepareBlank(width, height) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    return new this.constructor(canvas);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  sync() {\r\n    this.canvas.getContext('2d').putImageData(this.imageData, 0, 0);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getAverageColor() {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    canvas.getContext('2d').drawImage(this.canvas, 0, 0, this.width, this.height, 0, 0, 1, 1);\r\n    return Array.prototype.slice.call(\r\n      canvas.getContext('2d').getImageData(0, 0, 1, 1).data\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  resize(width, height) {\r\n    const dst = document.createElement('canvas');\r\n    dst.width = width;\r\n    dst.height = height;\r\n    dst.getContext('2d').drawImage(this.canvas, 0, 0, this.width, this.height, 0, 0, width, height);\r\n    return new this.constructor(dst);\r\n  }\r\n}\r\n\r\nexport default Canvas;","import Canvas from './canvas';\r\n\r\n/**\r\n * Wrapper for {@link lens.image.Canvas} for direct distortion of DOM Image objects.\r\n * Distortion result will contain new DOM Image object in {@link lens.image.DomImage#image} property.\r\n *\r\n * @implements {ImageInterface}\r\n * @memberOf lens.image\r\n * @extends lens.image.Canvas\r\n */\r\nclass DomImage extends Canvas {\r\n  /**\r\n   *\r\n   * @param {external:Image|HTMLImageElement} image DOM Image object\r\n   */\r\n  constructor(image) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    canvas.getContext('2d').drawImage(image, 0, 0);\r\n    super(canvas);\r\n\r\n    this.image = image;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  prepareBlank(width, height) {\r\n    return new this.constructor(new Image(width, height));\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  sync() {\r\n    super.sync();\r\n\r\n    return new Promise(resolve => {\r\n      this.image.onload = () => resolve(this);\r\n\r\n      this.image.src = this.canvas.toDataURL();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  resize(width, height) {\r\n    return this.sync().then(() => {\r\n      return new Promise(resolve => {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        canvas.getContext('2d').drawImage(this.image, 0, 0, this.width, this.height, 0, 0, width, height);\r\n\r\n        const image = new Image(width, height);\r\n\r\n        image.onload = () => {\r\n          const resized = new this.constructor(image);\r\n          resolve(resized);\r\n        };\r\n\r\n        image.src = canvas.toDataURL();\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nexport default DomImage;","import AbstractImage from './abstract-image';\r\nimport Canvas from './canvas';\r\nimport DomImage from './dom-image';\r\n\r\n/**\r\n * Image namespace\r\n *\r\n * @namespace lens.image\r\n */\r\nconst image = {\r\n  AbstractImage,\r\n  Canvas,\r\n  DomImage\r\n};\r\n\r\nexport default image;","import createsBestFitViewportFromApexes from './creates-best-fit-viewport-from-apexes';\r\nimport interpolationTrait from './interpolation-trait';\r\nimport virtualPixelTrait from './virtual-pixel-trait';\r\n\r\n/**\r\n * Mixins namespace\r\n *\r\n * @namespace lens.mixins\r\n */\r\nconst mixins = {\r\n  createsBestFitViewportFromApexes,\r\n  interpolationTrait,\r\n  virtualPixelTrait\r\n};\r\n\r\nexport default mixins;","import vpx from '../vpx';\r\nimport interpolation from '../interpolation';\r\nimport {MAXIMUM_VALUE} from \"../constants\";\r\nimport {blendColors} from \"../util/util\";\r\n\r\n/**\r\n * @private\r\n * @type {number}\r\n */\r\nconst WEIGHT_LOOKUP_TABLE_WIDTH = 1024;\r\n\r\n/**\r\n * @private\r\n * @param {FilterInterface} filter\r\n * @param {number} support\r\n * @returns {number[]}\r\n */\r\nfunction buildWeightLookupTable(filter, support) {\r\n  const table = [];\r\n\r\n  const rScale = support * Math.sqrt(1 / WEIGHT_LOOKUP_TABLE_WIDTH);\r\n\r\n  for (let Q = 0; Q < WEIGHT_LOOKUP_TABLE_WIDTH; Q++) {\r\n    table[Q] = filter.getWeight(Math.sqrt(Q) * rScale);\r\n  }\r\n\r\n  return table;\r\n}\r\n\r\n/**\r\n * @private\r\n * @param value\r\n * @param quantumRange\r\n * @returns {number}\r\n */\r\nfunction clampToQuantum(value, quantumRange) {\r\n  return Math.max(0, Math.min(quantumRange, value));\r\n}\r\n\r\n/**\r\n * <p>ClampEllipseAxes() function converts the input vectors into a major and\r\n * minor axis unit vectors, and their magnitude.  This allows us to\r\n * ensure that the ellipse generated is never smaller than the unit\r\n * circle and thus never too small for use in EWA resampling.</p>\r\n *\r\n * <p>This purely mathematical 'magic' was provided by Professor Nicolas\r\n * Robidoux and his Masters student Chantal Racette.</p>\r\n *\r\n * <p>Reference: \"We Recommend Singular Value Decomposition\", David Austin\r\n *   {@link http://www.ams.org/samplings/feature-column/fcarc-svd}</p>\r\n *\r\n * <p>By generating major and minor axis vectors, we can actually use the\r\n * ellipse in its \"canonical form\", by remapping the dx,dy of the\r\n * sampled point into distances along the major and minor axis unit\r\n * vectors.</p>\r\n *\r\n * <p>Reference: {@link http://en.wikipedia.org/wiki/Ellipse#Canonical_form}</p>\r\n *\r\n * @private\r\n * @param {number} dux\r\n * @param {number} duy\r\n * @param {number} dvx\r\n * @param {number} dvy\r\n * @returns {number[]}\r\n * @see {@link https://imagemagick.org/api/MagickCore/resample_8c_source.html#l00709 ClampUpAxes() at ImageMagick source}\r\n * @tutorial 02.03.pixel-color-lookup\r\n */\r\nfunction clampEllipseAxes(dux, duy, dvx, dvy) {\r\n  /*\r\n   * ClampUpAxes takes an input 2x2 matrix\r\n   *\r\n   * [ a b ] = [ dux duy ]\r\n   * [ c d ] = [ dvx dvy ]\r\n   *\r\n   * and computes from it the major and minor axis vectors [major_x,\r\n   * major_y] and [minor_x,minor_y] of the smallest ellipse containing\r\n   * both the unit disk and the ellipse which is the image of the unit\r\n   * disk by the linear transformation\r\n   *\r\n   * [ dux duy ] [S] = [s]\r\n   * [ dvx dvy ] [T] = [t]\r\n   *\r\n   * (The vector [S,T] is the difference between a position in output\r\n   * space and [X,Y]; the vector [s,t] is the difference between a\r\n   * position in input space and [x,y].)\r\n   */\r\n  /*\r\n   * Output:\r\n   *\r\n   * major_mag is the half-length of the major axis of the \"new\"\r\n   * ellipse.\r\n   *\r\n   * minor_mag is the half-length of the minor axis of the \"new\"\r\n   * ellipse.\r\n   *\r\n   * major_unit_x is the x-coordinate of the major axis direction vector\r\n   * of both the \"old\" and \"new\" ellipses.\r\n   *\r\n   * major_unit_y is the y-coordinate of the major axis direction vector.\r\n   *\r\n   * minor_unit_x is the x-coordinate of the minor axis direction vector.\r\n   *\r\n   * minor_unit_y is the y-coordinate of the minor axis direction vector.\r\n   *\r\n   * Unit vectors are useful for computing projections, in particular,\r\n   * to compute the distance between a point in output space and the\r\n   * center of a unit disk in output space, using the position of the\r\n   * corresponding point [s,t] in input space. Following the clamping,\r\n   * the square of this distance is\r\n   *\r\n   * ( ( s * major_unit_x + t * major_unit_y ) / major_mag )^2\r\n   * +\r\n   * ( ( s * minor_unit_x + t * minor_unit_y ) / minor_mag )^2\r\n   *\r\n   * If such distances will be computed for many [s,t]'s, it makes\r\n   * sense to actually compute the reciprocal of major_mag and\r\n   * minor_mag and multiply them by the above unit lengths.\r\n   *\r\n   * Now, if you want to modify the input pair of tangent vectors so\r\n   * that it defines the modified ellipse, all you have to do is set\r\n   *\r\n   * newdux = major_mag * major_unit_x\r\n   * newdvx = major_mag * major_unit_y\r\n   * newduy = minor_mag * minor_unit_x = minor_mag * -major_unit_y\r\n   * newdvy = minor_mag * minor_unit_y = minor_mag *  major_unit_x\r\n   *\r\n   * and use these tangent vectors as if they were the original ones.\r\n   * Usually, this is a drastic change in the tangent vectors even if\r\n   * the singular values are not clamped; for example, the minor axis\r\n   * vector always points in a direction which is 90 degrees\r\n   * counterclockwise from the direction of the major axis vector.\r\n   */\r\n  /*\r\n   * Discussion:\r\n   *\r\n   * GOAL: Fix things so that the pullback, in input space, of a disk\r\n   * of radius r in output space is an ellipse which contains, at\r\n   * least, a disc of radius r. (Make this hold for any r>0.)\r\n   *\r\n   * ESSENCE OF THE METHOD: Compute the product of the first two\r\n   * factors of an SVD of the linear transformation defining the\r\n   * ellipse and make sure that both its columns have norm at least 1.\r\n   * Because rotations and reflexions map disks to themselves, it is\r\n   * not necessary to compute the third (rightmost) factor of the SVD.\r\n   *\r\n   * DETAILS: Find the singular values and (unit) left singular\r\n   * vectors of Jinv, clampling up the singular values to 1, and\r\n   * multiply the unit left singular vectors by the new singular\r\n   * values in order to get the minor and major ellipse axis vectors.\r\n   *\r\n   * Image resampling context:\r\n   *\r\n   * The Jacobian matrix of the transformation at the output point\r\n   * under consideration is defined as follows:\r\n   *\r\n   * Consider the transformation (x,y) -> (X,Y) from input locations\r\n   * to output locations. (Anthony Thyssen, elsewhere in resample.c,\r\n   * uses the notation (u,v) -> (x,y).)\r\n   *\r\n   * The Jacobian matrix of the transformation at (x,y) is equal to\r\n   *\r\n   *   J = [ A, B ] = [ dX/dx, dX/dy ]\r\n   *       [ C, D ]   [ dY/dx, dY/dy ]\r\n   *\r\n   * that is, the vector [A,C] is the tangent vector corresponding to\r\n   * input changes in the horizontal direction, and the vector [B,D]\r\n   * is the tangent vector corresponding to input changes in the\r\n   * vertical direction.\r\n   *\r\n   * In the context of resampling, it is natural to use the inverse\r\n   * Jacobian matrix Jinv because resampling is generally performed by\r\n   * pulling pixel locations in the output image back to locations in\r\n   * the input image. Jinv is\r\n   *\r\n   *   Jinv = [ a, b ] = [ dx/dX, dx/dY ]\r\n   *          [ c, d ]   [ dy/dX, dy/dY ]\r\n   *\r\n   * Note: Jinv can be computed from J with the following matrix\r\n   * formula:\r\n   *\r\n   *   Jinv = 1/(A*D-B*C) [  D, -B ]\r\n   *                      [ -C,  A ]\r\n   *\r\n   * What we do is modify Jinv so that it generates an ellipse which\r\n   * is as close as possible to the original but which contains the\r\n   * unit disk. This can be accomplished as follows:\r\n   *\r\n   * Let\r\n   *\r\n   *   Jinv = U Sigma V^T\r\n   *\r\n   * be an SVD decomposition of Jinv. (The SVD is not unique, but the\r\n   * final ellipse does not depend on the particular SVD.)\r\n   *\r\n   * We could clamp up the entries of the diagonal matrix Sigma so\r\n   * that they are at least 1, and then set\r\n   *\r\n   *   Jinv = U newSigma V^T.\r\n   *\r\n   * However, we do not need to compute V for the following reason:\r\n   * V^T is an orthogonal matrix (that is, it represents a combination\r\n   * of rotations and reflexions) so that it maps the unit circle to\r\n   * itself. For this reason, the exact value of V does not affect the\r\n   * final ellipse, and we can choose V to be the identity\r\n   * matrix. This gives\r\n   *\r\n   *   Jinv = U newSigma.\r\n   *\r\n   * In the end, we return the two diagonal entries of newSigma\r\n   * together with the two columns of U.\r\n   */\r\n  /*\r\n   * ClampUpAxes was written by Nicolas Robidoux and Chantal Racette\r\n   * of Laurentian University with insightful suggestions from Anthony\r\n   * Thyssen and funding from the National Science and Engineering\r\n   * Research Council of Canada. It is distinguished from its\r\n   * predecessors by its efficient handling of degenerate cases.\r\n   *\r\n   * The idea of clamping up the EWA ellipse's major and minor axes so\r\n   * that the result contains the reconstruction kernel filter support\r\n   * is taken from Andreas Gustaffson's Masters thesis \"Interactive\r\n   * Image Warping\", Helsinki University of Technology, Faculty of\r\n   * Information Technology, 59 pages, 1993 (see Section 3.6).\r\n   *\r\n   * The use of the SVD to clamp up the singular values of the\r\n   * Jacobian matrix of the pullback transformation for EWA resampling\r\n   * is taken from the astrophysicist Craig DeForest.  It is\r\n   * implemented in his PDL::Transform code (PDL = Perl Data\r\n   * Language).\r\n   */\r\n\r\n  const a = dux;\r\n  const b = duy;\r\n  const c = dvx;\r\n  const d = dvy;\r\n\r\n  /*\r\n   * n is the matrix Jinv * transpose(Jinv). Eigenvalues of n are the\r\n   * squares of the singular values of Jinv.\r\n   */\r\n  const aa = a * a;\r\n  const bb = b * b;\r\n  const cc = c * c;\r\n  const dd = d * d;\r\n\r\n  /*\r\n   * Eigenvectors of n are left singular vectors of Jinv.\r\n   */\r\n  const n11 = aa + bb;\r\n  const n12 = a * c + b * d;\r\n  const n21 = n12;\r\n  const n22 = cc + dd;\r\n  const det = a * d - b * c;\r\n  const twice_det = det + det;\r\n  const frobenius_squared = n11 + n22;\r\n  const discriminant = (frobenius_squared + twice_det) * (frobenius_squared - twice_det);\r\n\r\n  /*\r\n   * In exact arithmetic, discriminant can't be negative. In floating\r\n   * point, it can, because of the bad conditioning of SVD\r\n   * decompositions done through the associated normal matrix.\r\n   */\r\n  const sqrt_discriminant = Math.sqrt(discriminant > 0 ? discriminant : 0);\r\n\r\n  /*\r\n   * s1 is the largest singular value of the inverse Jacobian\r\n   * matrix. In other words, its reciprocal is the smallest singular\r\n   * value of the Jacobian matrix itself.\r\n   * If s1 = 0, both singular values are 0, and any orthogonal pair of\r\n   * left and right factors produces a singular decomposition of Jinv.\r\n   */\r\n  /*\r\n   * Initially, we only compute the squares of the singular values.\r\n   */\r\n  const s1s1 = 0.5 * (frobenius_squared + sqrt_discriminant);\r\n\r\n  /*\r\n   * s2 the smallest singular value of the inverse Jacobian\r\n   * matrix. Its reciprocal is the largest singular value of the\r\n   * Jacobian matrix itself.\r\n   */\r\n  const s2s2 = 0.5 * (frobenius_squared - sqrt_discriminant);\r\n  const s1s1minusn11 = s1s1 - n11;\r\n  const s1s1minusn22 = s1s1 - n22;\r\n\r\n  /*\r\n   * u1, the first column of the U factor of a singular decomposition\r\n   * of Jinv, is a (non-normalized) left singular vector corresponding\r\n   * to s1. It has entries u11 and u21. We compute u1 from the fact\r\n   * that it is an eigenvector of n corresponding to the eigenvalue\r\n   * s1^2.\r\n   */\r\n  const s1s1minusn11_squared = s1s1minusn11 * s1s1minusn11;\r\n  const s1s1minusn22_squared = s1s1minusn22 * s1s1minusn22;\r\n\r\n  /*\r\n   * The following selects the largest row of n-s1^2 I as the one\r\n   * which is used to find the eigenvector. If both s1^2-n11 and\r\n   * s1^2-n22 are zero, n-s1^2 I is the zero matrix.  In that case,\r\n   * any vector is an eigenvector; in addition, norm below is equal to\r\n   * zero, and, in exact arithmetic, this is the only case in which\r\n   * norm = 0. So, setting u1 to the simple but arbitrary vector [1,0]\r\n   * if norm = 0 safely takes care of all cases.\r\n   */\r\n  const temp_u11 = (s1s1minusn11_squared >= s1s1minusn22_squared) ? n12 : s1s1minusn22;\r\n  const temp_u21 = (s1s1minusn11_squared >= s1s1minusn22_squared) ? s1s1minusn11 : n21;\r\n  const norm = Math.sqrt(temp_u11 * temp_u11 + temp_u21 * temp_u21);\r\n\r\n  /*\r\n   * Finalize the entries of first left singular vector (associated\r\n   * with the largest singular value).\r\n   */\r\n  const u11 = norm > 0 ? temp_u11 / norm : 1;\r\n  const u21 = norm > 0 ? temp_u21 / norm : 0;\r\n\r\n  /*\r\n   * Clamp the singular values up to 1.\r\n   */\r\n  const major_mag = s1s1 <= 1 ? 1 : Math.sqrt(s1s1);\r\n  const minor_mag = s2s2 <= 1 ? 1 : Math.sqrt(s2s2);\r\n\r\n\r\n  const major_x = u11 * major_mag;\r\n  const major_y = u21 * major_mag;\r\n  const minor_x = -u21 * minor_mag;\r\n  const minor_y = u11 * minor_mag;\r\n\r\n  return [\r\n    major_x,\r\n    major_y,\r\n    minor_x,\r\n    minor_y,\r\n    major_mag,\r\n    minor_mag\r\n  ];\r\n}\r\n\r\n/**\r\n * Elliptical Weighted Average.\r\n * Resamples pixel color using Elliptical Weighted Average technique.\r\n *\r\n * @implements {ResamplerInterface}\r\n * @memberOf lens.resampler\r\n * @see {@link https://www.imagemagick.org/Usage/distorts/#distort_ewa EWA details} at ImageMagick docs.\r\n * @see {@link https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/CSD-89-516.pdf Fundamentals of Texture Mapping and Image Warping by Paul S. Heckbert}\r\n * page 41, section 3.4, 3.5\r\n * @see {@link https://imagemagick.org/api/MagickCore/resample_8c_source.html#l01038 ScaleResampleFilter()} at\r\n * ImageMagick source.\r\n * @see {@link https://imagemagick.org/api/MagickCore/resample_8c_source.html#l00315 ResamplePixelColor()} at\r\n * ImageMagick source.\r\n */\r\nclass EWA {\r\n\r\n  /**\r\n   *\r\n   * @param {FilterInterface} filter\r\n   */\r\n  constructor(filter) {\r\n    /**\r\n     * Reconstruction filter.\r\n     * @protected\r\n     * @type {FilterInterface}\r\n     */\r\n    this.resizeFilter = filter;\r\n\r\n    /**\r\n     * The practical working support of the filter\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.support = this.resizeFilter.support * this.resizeFilter.blur;\r\n\r\n    /**\r\n     * Matte color for invalid mappings.\r\n     * @type {Color}\r\n     */\r\n    this.matteColor = [0, 0, 0, 0];\r\n\r\n    /**\r\n     * Lookup table of weights for filtered average in elliptical area.\r\n     * @protected\r\n     * @type {number[]}\r\n     */\r\n    this.weightLookupTable = buildWeightLookupTable(this.resizeFilter, this.support);\r\n\r\n    /**\r\n     * Image being resampled.\r\n     * @type {ImageInterface}\r\n     */\r\n    this.image = null;\r\n\r\n    /**\r\n     * Distortion mapper.\r\n     * @protected\r\n     * @type {DistortionInterface}\r\n     */\r\n    this.mapper = null;\r\n\r\n    /**\r\n     * Cached for direct access image virtual viewport.\r\n     * @protected\r\n     * @type {lens.Viewport}\r\n     */\r\n    this.imageViewport = null;\r\n\r\n    /**\r\n     * Cached image area.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.imageArea = null;\r\n\r\n    /**\r\n     * Cached for direct access image virtual pixel method.\r\n     * @protected\r\n     * @type {lens.vpx}\r\n     */\r\n    this.imageVirtualPixelMethod = null;\r\n\r\n    /**\r\n     * Cached image average color.\r\n     * @protected\r\n     * @type {Color|null}\r\n     */\r\n    this.imageAverageColor = null;\r\n\r\n    /**\r\n     * Ellipse equiation A.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.A = 0;\r\n\r\n    /**\r\n     * Ellipse equation B.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.B = 0;\r\n\r\n    /**\r\n     * Ellipse equation C.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.C = 0;\r\n\r\n    /**\r\n     * Ellipse equation F.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.F = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.uLimit = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.vLimit = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.uWidth = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.slope = 0;\r\n\r\n    /**\r\n     * Used for distortions with constant partial derivatives to flag that ellipse already has been set up.\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.ellipseIsSetUp = false;\r\n\r\n    /**\r\n     * Flags that ellipse is too large and it is impractical to resample color -- better use some of possible\r\n     * optimizations.\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.limitReached = false;\r\n\r\n    /**\r\n     * Output image scaling factor.\r\n     * @type {number}\r\n     */\r\n    this.scaling = 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getResampledColor(x, y) {\r\n    x = x * this.scaling;\r\n    y = y * this.scaling;\r\n\r\n    const validity = this.mapper.getValidity(x, y, this.scaling);\r\n\r\n    if (validity > 0) {\r\n      const [u, v] = this.mapper.reverseMap(x, y);\r\n\r\n      if (this.mapper.hasConstantPartialDerivatives) {\r\n        this.setupEllipseOnce(...this.mapper.getPartialDerivatives(x, y));\r\n      } else {\r\n        this.setupEllipse(...this.mapper.getPartialDerivatives(x, y));\r\n      }\r\n\r\n      const color = this.getWeightedAverage(u, v);\r\n\r\n      if (validity < 1) {\r\n        return blendColors(color, validity, this.matteColor);\r\n      }\r\n\r\n      return color;\r\n    }\r\n\r\n    return this.matteColor.slice();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setImage(image) {\r\n    this.image = image;\r\n    // cache image viewport for faster direct access.\r\n    this.imageViewport = this.image.viewport;\r\n    // cache image area.\r\n    this.imageArea = this.imageViewport.area();\r\n    // cache image virtual pixel method (will it be faster actually?)\r\n    this.imageVirtualPixelMethod = this.image.virtualPixelMethod;\r\n    // reset cached image average color\r\n    this.imageAverageColor = null;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setMapper(mapper) {\r\n    if (!mapper.hasPartialDerivatives) {\r\n      throw new Error('Pixel mapper must have partial derivatives to use this resampler');\r\n    }\r\n\r\n    this.mapper = mapper;\r\n    this.ellipseIsSetUp = false;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculates ellipse once for distortions with constant partial derivatives.\r\n   *\r\n   * @private\r\n   * @param derivatives\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  setupEllipseOnce(...derivatives) {\r\n    if (!this.ellipseIsSetUp) {\r\n      this.ellipseIsSetUp = true;\r\n      return this.setupEllipse(...derivatives);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculates ellipse for EWA resampling using partial derivatives.\r\n   *\r\n   * @private\r\n   * @param derivatives\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  setupEllipse(...derivatives) {\r\n    this.limitReached = false;\r\n\r\n    derivatives = derivatives.map(derivative => derivative * this.scaling);\r\n\r\n    return this.initEllipse(...derivatives)\r\n      .scaleEllipse();\r\n  }\r\n\r\n  /**\r\n   * Calculates ellipse equation for given distortion partial derivatives.\r\n   *\r\n   * @private\r\n   * @param derivatives\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  initEllipse(...derivatives) {\r\n    const [\r\n      major_x,\r\n      major_y,\r\n      minor_x,\r\n      minor_y,\r\n      major_mag,\r\n      minor_mag\r\n    ] = clampEllipseAxes(...derivatives);\r\n\r\n    this.A = major_y * major_y + minor_y * minor_y;\r\n    this.B = -2 * (major_x * major_y + minor_x * minor_y);\r\n    this.C = major_x * major_x + minor_x * minor_x;\r\n    this.F = major_mag * minor_mag;\r\n    this.F *= this.F;\r\n\r\n    /*\r\n     * If one or both of the scaling vectors is impossibly large\r\n     * (producing a very large raw F value), we may as well not bother\r\n     * doing any form of resampling since resampled area is very large.\r\n     * In this case some alternative means of pixel sampling, such as\r\n     * the average of the whole image is needed to get a reasonable\r\n     * result. Calculate only as needed.\r\n     */\r\n    this.limitReached = 4 * this.A * this.C - this.B * this.B > MAXIMUM_VALUE;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales ellipse to match filter support.\r\n   *\r\n   * @private\r\n   * @returns {lens.resampler.EWA}\r\n   */\r\n  scaleEllipse() {\r\n    if (!this.limitReached) {\r\n      this.F *= this.support * this.support;\r\n      this.uLimit = Math.sqrt(this.C * this.F / (this.A * this.C - 0.25 * this.B * this.B));\r\n      this.vLimit = Math.sqrt(this.A * this.F / (this.A * this.C - 0.25 * this.B * this.B));\r\n      this.uWidth = Math.sqrt(this.F / this.A);\r\n      this.slope = -this.B / (2 * this.A);\r\n\r\n      /*\r\n       * Check the absolute area of the parallelogram involved.\r\n       * This limit needs more work, as it is too slow for larger images\r\n       * with tiled views of the horizon.\r\n       */\r\n      if (this.uWidth * this.vLimit > 4 * this.imageArea) {\r\n        this.limitReached = true;\r\n        return this;\r\n      }\r\n\r\n      /* Scale ellipse formula to directly index the Filter Lookup Table */\r\n      const scale = WEIGHT_LOOKUP_TABLE_WIDTH / this.F;\r\n      this.A *= scale;\r\n      this.B *= scale;\r\n      this.C *= scale;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns weighted average color at given point using scaled EWA ellipse.\r\n   *\r\n   * @private\r\n   * @param {number} u0\r\n   * @param {number} v0\r\n   * @returns {Color}\r\n   */\r\n  getWeightedAverage(u0, v0) {\r\n    if (this.doesntNeedResampling(u0, v0)) {\r\n      /* The area being resampled is simply a solid color\r\n       * just return a single lookup color.\r\n       */\r\n      return this.image.getPixelColor(u0, v0);\r\n    }\r\n\r\n    if (this.limitReached) {\r\n      // When Scaling limits reached, return an 'averaged' result.\r\n\r\n      switch (this.imageVirtualPixelMethod) {\r\n        case vpx.EDGE:\r\n        case vpx.HORIZONTAL_TILE_EDGE:\r\n        case vpx.VERTICAL_TILE_EDGE:\r\n          /*\r\n           * We need an average edge pixel, from the correct edge!\r\n           * How should I calculate an average edge color?\r\n           * Just returning an averaged neighbourhood,\r\n           * works well in general, but falls down for TileEdge methods.\r\n           * This needs to be done properly!!!!!!\r\n           */\r\n          return this.image.getInterpolatedPixelColor(u0, v0, interpolation.AVERAGE);\r\n        case vpx.HORIZONTAL_TILE:\r\n        case vpx.VERTICAL_TILE:\r\n          /*\r\n          * just return the background pixel - Is there more direct way?\r\n          */\r\n          return this.image.getPixelColor(\r\n            this.imageViewport.x1 - 1,\r\n            this.imageViewport.y1 - 1\r\n          );\r\n        default:\r\n          return this.getImageAverageColor();\r\n      }\r\n    }\r\n\r\n    let divisorM = 0,\r\n      divisorC = 0,\r\n      red = 0,\r\n      green = 0,\r\n      blue = 0,\r\n      alpha = 0;\r\n\r\n    /*\r\n     * Determine the parellelogram bounding box fitted to the ellipse\r\n     * centered at u0,v0.  This area is bounding by the lines...\r\n     */\r\n    const v1 = Math.ceil(v0 - this.vLimit);\r\n    const v2 = Math.floor(v0 + this.vLimit);\r\n\r\n    // scan line start and width accross the parallelogram\r\n    let u1 = u0 + (v1 - v0) * this.slope - this.uWidth;\r\n    let uw = 2 * this.uWidth + 1;\r\n\r\n    /*\r\n     * Do weighted resampling of all pixels,  within the scaled ellipse,\r\n     * bound by a Parellelogram fitted to the ellipse.\r\n     */\r\n\r\n    let DDQ = 2 * this.A;\r\n\r\n    for (let v = v1; v < v2; v++) {\r\n      let ustart = Math.ceil(u1); // first pixel in scanline\r\n      u1 += this.slope; // start of next scan line\r\n      let uend = ustart + uw;\r\n\r\n      // location of this first pixel, relative to u0,v0\r\n      let U = ustart - u0;\r\n      let V = v - v0;\r\n\r\n      // Q = ellipse quotent ( if Q<F then pixel is inside ellipse)\r\n      let Q = (this.A * U + this.B * V) * U + this.C * V * V;\r\n      let DQ = this.A * (2 * U + 1) + this.B * V;\r\n\r\n      // count up the weighted pixel colors\r\n      for (let u = ustart; u < uend; u++) {\r\n        // Note that the ellipse has been pre-scaled so F = $this->weightLookupTableWidth\r\n        if (Q < WEIGHT_LOOKUP_TABLE_WIDTH) {\r\n          let weight = this.weightLookupTable[Math.floor(Q)];\r\n          let [r, g, b, a] = this.image.getPixelColor(u, v);\r\n          alpha += weight * a;\r\n          divisorM += weight;\r\n\r\n          weight *= (a / this.image.quantumRange);\r\n\r\n          red += r * weight;\r\n          green += g * weight;\r\n          blue += b * weight;\r\n          divisorC += weight;\r\n        }\r\n\r\n        Q += DQ;\r\n        DQ += DDQ;\r\n      }\r\n    }\r\n\r\n    // Result sanity check -- this should NOT happen\r\n    if (!divisorC || !divisorM) {\r\n      /*\r\n       * not enough pixels, or bad weighting in resampling,\r\n       * resort to direct interpolation\r\n       */\r\n      return this.image.getInterpolatedPixelColor(u0, v0);\r\n    }\r\n\r\n    return [\r\n      clampToQuantum(Math.round(red / divisorC), this.image.quantumRange),\r\n      clampToQuantum(Math.round(green / divisorC), this.image.quantumRange),\r\n      clampToQuantum(Math.round(blue / divisorC), this.image.quantumRange),\r\n      clampToQuantum(Math.round(alpha / divisorM), this.image.quantumRange)\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Checks if no resampling is needed (if single pixel color should be returned).\r\n   *\r\n   * @private\r\n   * @param {number} u\r\n   * @param {number} v\r\n   * @returns {boolean}\r\n   */\r\n  doesntNeedResampling(u, v) {\r\n    switch (this.imageVirtualPixelMethod) {\r\n      case vpx.TRANSPARENT:\r\n      case vpx.BACKGROUND:\r\n      case vpx.BLACK:\r\n      case vpx.WHITE:\r\n      case vpx.GRAY:\r\n        return this.limitReached || this.outOfImageBounds(u, v);\r\n      case vpx.EDGE:\r\n        return (u + this.uLimit < this.imageViewport.x1 && v + this.vLimit < this.imageViewport.y1) ||\r\n          (u + this.uLimit < this.imageViewport.x1 && v - this.vLimit > this.imageViewport.y2) ||\r\n          (u - this.uLimit > this.imageViewport.x2 && v + this.vLimit < this.imageViewport.y1) ||\r\n          (u - this.uLimit > this.imageViewport.x2 && v - this.vLimit > this.imageViewport.y2);\r\n      case vpx.HORIZONTAL_TILE:\r\n        return v + this.vLimit < this.imageViewport.y1 || v - this.vLimit > this.imageViewport.y2;\r\n      case vpx.VERTICAL_TILE:\r\n        return u + this.uLimit < this.imageViewport.x1 || u - this.uLimit > this.imageViewport.x2;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Laziliy returns cached image average color.\r\n   *\r\n   * @private\r\n   * @returns {Color}\r\n   */\r\n  getImageAverageColor() {\r\n    if (this.imageAverageColor === null) {\r\n      this.imageAverageColor = this.image.getAverageColor();\r\n    }\r\n\r\n    return this.imageAverageColor.slice();\r\n  }\r\n\r\n  /**\r\n   * Checks if ellipse is completely out of image bounds.\r\n   *\r\n   * @private\r\n   * @param {number} u\r\n   * @param {number} v\r\n   * @returns {boolean}\r\n   */\r\n  outOfImageBounds(u, v) {\r\n    return u + this.uLimit < this.imageViewport.x1 ||\r\n      u - this.uLimit > this.imageViewport.x2 ||\r\n      v + this.vLimit < this.imageViewport.y1 ||\r\n      v - this.vLimit > this.imageViewport.y2;\r\n  }\r\n}\r\n\r\nexport default EWA;","import {blendColors} from \"../util/util\";\r\n\r\n/**\r\n * <p>{@link ResamplerInterface} implementaion without resampling itself.</p>\r\n * <p>It uses pixel color interpolation and works much faster than {@link lens.resampler.EWA} but produces aliasing\r\n * effects.</p>\r\n * <p>It is good for quick creation of distortion previews and also used for {@link DistortionInterface} implementations\r\n * that doesn't have partial derivatives.</p>\r\n * <p>It works most quickly when {@link ImageInterface}#interpolationMethod property is set to\r\n * {@link lens.interpolation.INTEGER}</p>\r\n *\r\n * @implements {ResamplerInterface}\r\n * @memberOf lens.resampler\r\n * @tutorial 02.03.pixel-color-lookup\r\n */\r\nclass Point {\r\n\r\n  constructor() {\r\n    this.matteColor = [0, 0, 0, 0];\r\n    this.scaling = 1;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setImage(image) {\r\n    this.image = image;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  setMapper(mapper) {\r\n    this.mapper = mapper;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  getResampledColor(x, y) {\r\n    x = x * this.scaling;\r\n    y = y * this.scaling;\r\n\r\n    const validity = this.mapper.getValidity(x, y, this.scaling);\r\n\r\n    if (validity > 0) {\r\n      let [u, v] = this.mapper.reverseMap(x, y);\r\n      let color = this.image.getInterpolatedPixelColor(u, v);\r\n\r\n      if (validity < 1) {\r\n        return blendColors(color, this.matteColor, validity);\r\n      }\r\n\r\n      return color;\r\n    }\r\n\r\n    return this.matteColor.slice();\r\n  }\r\n}\r\n\r\nexport default Point;","import EWA from './e-w-a';\r\nimport Point from './point';\r\n\r\n/**\r\n * Resampler namespace\r\n *\r\n * @namespace lens.resampler\r\n */\r\nconst resampler = {\r\n  EWA,\r\n  Point\r\n};\r\n\r\nexport default resampler;","import * as utils from './util';\r\nimport gaussJordanElimination from './gauss-jordan-elimination/gauss-jordan-elimination';\r\n\r\n/**\r\n * Utility functions namespace\r\n *\r\n * @namespace lens.util\r\n */\r\nconst util = {\r\n  ...utils,\r\n  gaussJordanElimination\r\n};\r\n\r\nexport default util;","import Solver from './solver';\r\nimport LeastSquares from './least-squares';\r\n\r\n/**\r\n * Gauss Jordan Elimination namespace\r\n *\r\n * @namespace lens.util.gaussJordanElimination\r\n */\r\nconst gaussJordanElimination = {\r\n  Solver,\r\n  LeastSquares\r\n};\r\n\r\nexport default gaussJordanElimination;","import Filter from './filter/filter';\r\nimport {box, cubicBC} from \"./filter/filter-functions\";\r\n\r\n/**\r\n * Filter factory.\r\n *\r\n * @callback lens~filterFactory\r\n * @returns {FilterInterface}\r\n */\r\n\r\n/**\r\n * @private\r\n * @returns {lens.filter.Filter}\r\n * @constructor\r\n */\r\nfunction ROBIDOUX() {\r\n  return new Filter(\r\n    cubicBC(0.37821575509399867, 0.31089212245300067),\r\n    box(),\r\n    2,\r\n    1.1685777620836932,\r\n    1\r\n  );\r\n}\r\n\r\n/**\r\n * @private\r\n * @returns {lens.filter.Filter}\r\n * @constructor\r\n */\r\nfunction ROBIDOUX_SHARP() {\r\n  return new Filter(\r\n    cubicBC(0.2620145123990142, 0.3689927438004929),\r\n    box(),\r\n    2,\r\n    1.105822933719019,\r\n    1\r\n  );\r\n}\r\n\r\n/**\r\n * Filter presets.\r\n *\r\n * @enum {lens~filterFactory}\r\n * @memberOf lens\r\n */\r\nconst filterPresets = {\r\n  ROBIDOUX,\r\n  ROBIDOUX_SHARP\r\n};\r\n\r\n// TODO add more filter presets\r\n\r\nexport default filterPresets;","import * as distorter from \"./distorter\";\r\nimport * as resampler from \"./resampler\";\r\nimport filterPresets from './filter-presets';\r\n\r\nlet defaultOptions = {\r\n  bestFit: false,\r\n  filter: filterPresets.ROBIDOUX,\r\n  resample: true,\r\n  async: true,\r\n  outputScaling: 1\r\n};\r\n\r\n/**\r\n * @function\r\n * @name distort\r\n * @memberOf lens\r\n * @variation 2\r\n *\r\n * @param {ImageInterface} image\r\n * @param {DistortionInterface} distortion\r\n * @param {DistortionOptions} options\r\n *\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\n\r\n/**\r\n * Performs distortion of image\r\n *\r\n * @memberOf lens\r\n * @param {ImageInterface} image\r\n * @param {lens.distorts|lens~distortionResolver} distortion\r\n * @param {array} args\r\n * @param {DistortionOptions} [options]\r\n *\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\nfunction distort(image, distortion, args, options = {}) {\r\n  try {\r\n    if (typeof distortion === 'function') {\r\n      distortion  = distortion(args, image);\r\n    } else {\r\n      options     = args || {};\r\n    }\r\n\r\n    options = makeOptions(options);\r\n\r\n    if (distortion.forceBestFit) {\r\n      options.bestFit = true;\r\n    }\r\n\r\n    let distorted = sync(\r\n      makeDistorter(\r\n        image,\r\n        distortion,\r\n        makeResampler(image, distortion, options),\r\n        options\r\n      ).distort()\r\n    );\r\n\r\n    if (options.supersample && options.supersample !== 1) {\r\n      return scaleSupersampled(distorted, 1 / options.supersample);\r\n    }\r\n\r\n    return distorted;\r\n  } catch (e) {\r\n    if (options && options.async) {\r\n      return Promise.reject(e);\r\n    }\r\n\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * Sync ImageInterface internal data storage with image object.\r\n *\r\n * @private\r\n * @param {ImageInterface|Promise<ImageInterface>} distorted\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\nfunction sync(distorted) {\r\n  if (distorted instanceof Promise) {\r\n    return distorted.then(distorted => sync(distorted));\r\n  }\r\n\r\n  if ('sync' in distorted && typeof distorted.sync === 'function') {\r\n    return distorted.sync();\r\n  }\r\n\r\n  return distorted;\r\n}\r\n\r\n/**\r\n * Scales supersampled image back to normal size.\r\n *\r\n * @private\r\n * @param {ImageInterface|Promise<ImageInterface>} supersampled\r\n * @param {number} scale\r\n * @returns {ImageInterface|Promise<ImageInterface>}\r\n */\r\nfunction scaleSupersampled(supersampled, scale) {\r\n  if (supersampled instanceof Promise) {\r\n    return supersampled.then(supersampled => scaleSupersampled(supersampled, scale));\r\n  }\r\n\r\n  if ('scale' in supersampled && typeof supersampled.scale === 'function') {\r\n    return supersampled.scale(scale);\r\n  } else {\r\n    console.warn(`Method 'scale()' not found in image object. No scaling performed.`);\r\n  }\r\n\r\n  return supersampled;\r\n}\r\n\r\n/**\r\n * Makes valid options for distortion\r\n *\r\n * @private\r\n * @param {DistortionOptions} options\r\n * @returns {DistortionOptions}\r\n */\r\nfunction makeOptions(options) {\r\n  options = Object.assign({}, defaultOptions, options);\r\n\r\n  if (options.supersample) {\r\n    options.outputScaling = options.supersample;\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\n/**\r\n * Makes image distorter\r\n *\r\n * @private\r\n * @param {ImageInterface} image\r\n * @param {DistortionInterface} distortion\r\n * @param {ResamplerInterface} resampler\r\n * @param {DistortionOptions} options\r\n * @returns {ReversePixelMapping}\r\n */\r\nfunction makeDistorter(image, distortion, resampler, options) {\r\n  const dist = new distorter.ReversePixelMapping(image, distortion, resampler);\r\n  dist.async = !!options.async;\r\n  dist.bestFit = !!options.bestFit;\r\n\r\n  if (options.viewport) {\r\n    dist.viewport = options.viewport;\r\n  }\r\n\r\n  if (options.outputScaling) {\r\n    dist.outputScaling = options.outputScaling;\r\n\r\n    if (options.supersample) {\r\n      dist.supersample = true;\r\n    }\r\n  }\r\n\r\n  return dist;\r\n}\r\n\r\n/**\r\n * Makes resampler\r\n *\r\n * @private\r\n * @param {ImageInterface} image\r\n * @param {DistortionInterface} distortion\r\n * @param {DistortionOptions} options\r\n * @returns {ResamplerInterface}\r\n */\r\nfunction makeResampler(image, distortion, options) {\r\n  let rsm;\r\n\r\n  if (options.resampler) {\r\n    rsm = options.resampler;\r\n  } else if (options.resample) {\r\n    rsm = new resampler.EWA(makeFilter(options));\r\n  } else {\r\n    rsm = new resampler.Point();\r\n  }\r\n\r\n  if (options.matteColor) {\r\n    rsm.matteColor = options.matteColor.slice();\r\n  }\r\n\r\n  return rsm;\r\n}\r\n\r\n/**\r\n * Makes filter\r\n *\r\n * @private\r\n * @param {DistortionOptions} options\r\n * @returns {FilterInterface}\r\n */\r\nfunction makeFilter(options) {\r\n  if (typeof options.filter === 'function') {\r\n    return options.filter();\r\n  }\r\n\r\n  return options.filter;\r\n}\r\n\r\nexport default distort;","import Affine from './distortion/affine';\r\nimport Arc from './distortion/arc';\r\nimport Perspective from './distortion/perspective';\r\n\r\n/**\r\n * @summary Resolves distortion class instance using distortion arguments and optionally image.\r\n *\r\n * @callback lens~DistortionResolver\r\n * @param {number[]} args\r\n * @param {ImageInterface} [image]\r\n * @returns {DistortionInterface}\r\n */\r\n\r\n/**\r\n * Make Affine distortion using control points.\r\n *\r\n * @private\r\n * @param {number[]} args\r\n * @returns {lens.distortion.Affine}\r\n */\r\nfunction affineByControlPoints(args) {\r\n  return Affine.fromControlPoints(args);\r\n}\r\n\r\n/**\r\n * Make Affine distortion using affine matrix. Arguments order is as described for compatibility with ImageMagick\r\n * arguments.\r\n *\r\n * @private\r\n * @param sx\r\n * @param ry\r\n * @param rx\r\n * @param sy\r\n * @param tx\r\n * @param ty\r\n * @returns {lens.distortion.Affine}\r\n */\r\nfunction affineByMatrix ([sx, ry, rx, sy, tx, ty]) {\r\n  // Change arguments order.\r\n  return Affine.fromForwardMatrix([sx, rx, tx, ry, sy, ty]);\r\n}\r\n\r\n/**\r\n * Make perspective distortion using control points.\r\n * If number of control point sets is less than 4 (< 16 arguments), this will fallback to Affine distortion.\r\n *\r\n * @private\r\n * @param {number[]} args\r\n * @returns {lens.distortion.Perspective|lens.distortion.Affine}\r\n */\r\nfunction perspectiveByControlPoints(args) {\r\n  if (args.length < 16) {\r\n    console.warn('Perspective distortion requires at least 4 controls points mapping (u, v) -> (x, y). Affine distortion will be used.');\r\n    return Affine.fromControlPoints(args);\r\n  }\r\n\r\n  return Perspective.fromControlPoints(args);\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number[]} args\r\n * @returns {lens.distortion.Perspective}\r\n */\r\nfunction perspectiveByMatrix(args) {\r\n  return Perspective.fromForwardMatrix(args);\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {number[]} args\r\n * @param {ImageInterface} image\r\n * @returns {lens.distortion.Arc}\r\n */\r\nfunction arcByArguments(args, image) {\r\n  return Arc.fromArguments(image.viewport, args);\r\n}\r\n\r\n/**\r\n * Distortion types.\r\n *\r\n * @enum {lens~distortionResolver}\r\n * @memberOf lens\r\n */\r\nconst distorts = {\r\n  /**\r\n   * Affine distortion using control points. Arguments are sets of control points mappings:\r\n   * [u0, v0, x0, y0, ..., uN, vN, xN, yN], where u*, v* are source image coords, x*, y* are\r\n   * destination image coords.\r\n   */\r\n  AFFINE: affineByControlPoints,\r\n  /**\r\n   * Affine distortion using forward affine matrix.\r\n   * Arguments are affine matrix coefficients: [sx, ry, rx, sy, tx, ty]\r\n   */\r\n  AFFINE_PROJECTION: affineByMatrix,\r\n  /**\r\n   * Perspective distortion using control points. Arguments are sets of control points mappings:\r\n   * [u0, v0, x0, y0, ..., uN, vN, xN, yN], where u*, v* are source image coords, x*, y* are\r\n   * destination image coords.\r\n   * If number of control point sets is less than 4 (< 16 arguments), this will fallback to Affine distortion\r\n   * with warning message in console.\r\n   */\r\n  PERSPECTIVE: perspectiveByControlPoints,\r\n  /**\r\n   * Perspective distortion using forward perspective matrix. Arguments are perspective matrix coefficients:\r\n   * [sx, ry, tx, rx, sy, ty, px, py].\r\n   */\r\n  PERSPECTIVE_PROJECTION: perspectiveByMatrix,\r\n\r\n  /**\r\n   * Arc distortion. Arguments are: [arcAngle, rotation, outerRadius, innerRadius]. All arguments except arcAngle\r\n   * are optional. See {@link lens.distortion.Arc.fromArguments}\r\n   */\r\n  ARC: arcByArguments\r\n};\r\n\r\n/**\r\n * Register custom distortion resolver.\r\n *\r\n * @memberOf lens\r\n * @param {string} name\r\n * @param {lens~distortionResolver} resolver\r\n */\r\nfunction registerDistortionResolver(name, resolver) {\r\n  distorts[name]  = resolver;\r\n}\r\n\r\n/**\r\n * Unregister distortion resolver.\r\n *\r\n * @memberOf lens\r\n * @param {string} name\r\n */\r\nfunction unregisterDistortionResolver(name) {\r\n  delete distorts[name];\r\n}\r\n\r\nexport {registerDistortionResolver, unregisterDistortionResolver};\r\n\r\nexport default distorts;","import distorter from './distorter/distorter';\r\nimport distortion from './distortion/distortion';\r\nimport exception from './exception/exception';\r\nimport filter from './filter/filter-namespace';\r\nimport image from './image/image';\r\nimport mixins from './mixins/mixins';\r\nimport resampler from './resampler/resampler';\r\nimport util from './util/util-namespace';\r\nimport {EPSILON, MAXIMUM_VALUE, M_2PI, M_PI2} from './constants';\r\nimport distort from './distort';\r\nimport distorts from './distorts';\r\nimport {registerDistortionResolver, unregisterDistortionResolver} from './distorts';\r\nimport filterPresets from './filter-presets';\r\nimport interpolation from './interpolation';\r\nimport Viewport from './viewport';\r\nimport vpx from './vpx';\r\n\r\n/**\r\n * Library version\r\n * @memberOf lens\r\n */\r\nconst VERSION = process.env.PACKAGE_VERSION;\r\n\r\n/**\r\n * Lens library namespace\r\n *\r\n * @namespace lens\r\n */\r\nconst lens = {\r\n  // Constants\r\n  VERSION,\r\n  EPSILON,\r\n  MAXIMUM_VALUE,\r\n  M_2PI,\r\n  M_PI2,\r\n\r\n  // Enums\r\n  distorts,\r\n  filterPresets,\r\n  interpolation,\r\n  vpx,\r\n\r\n  // Types\r\n  Viewport,\r\n\r\n  // Namespaces\r\n  distorter,\r\n  distortion,\r\n  exception,\r\n  filter,\r\n  image,\r\n  mixins,\r\n  resampler,\r\n  util,\r\n\r\n  // Functions\r\n  distort,\r\n  registerDistortionResolver,\r\n  unregisterDistortionResolver\r\n};\r\n\r\nexport default lens;"],"sourceRoot":""}